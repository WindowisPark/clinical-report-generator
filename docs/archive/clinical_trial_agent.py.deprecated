"""
ì„ìƒì‹œí—˜ ìŠ¤í¬ë¦¬ë‹ ìë™í™” ì‹œìŠ¤í…œ - Phase 2
LangChain/LangGraph ê¸°ë°˜ êµ¬í˜„
"""

import pandas as pd
import os
import re
import yaml
import json
from datetime import datetime, timedelta
from jinja2 import Template
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from pathlib import Path
from enum import Enum
import google.generativeai as genai


@dataclass
class ReferenceData:
    """ì°¸ì¡° ë°ì´í„°ë¥¼ ë‹´ëŠ” ë°ì´í„° í´ë˜ìŠ¤"""
    diseases: pd.DataFrame
    drugs: pd.DataFrame
    ingredients: pd.DataFrame
    procedures: pd.DataFrame
    hospitals: pd.DataFrame
    disease_codes: pd.DataFrame


class ReferenceDataLoader:
    """ì°¸ì¡° ë°ì´í„° ë¡œë” - CSV íŒŒì¼ë“¤ì„ ë¡œë“œí•˜ê³  ê²€ìƒ‰ ê¸°ëŠ¥ ì œê³µ"""

    def __init__(self, reference_dir: str = "reference_data"):
        self.reference_dir = Path(reference_dir)
        self.data: Optional[ReferenceData] = None

    def load_all_data(self) -> ReferenceData:
        """ëª¨ë“  ì°¸ì¡° ë°ì´í„° ë¡œë“œ"""
        print("Loading reference data...")

        # CSV íŒŒì¼ë“¤ ë¡œë“œ
        diseases_df = pd.read_csv(self.reference_dir / "unique_diseases.csv")
        drugs_df = pd.read_csv(self.reference_dir / "unique_drugs.csv")
        ingredients_df = pd.read_csv(self.reference_dir / "unique_ingredients.csv")
        procedures_df = pd.read_csv(self.reference_dir / "unique_procedures.csv")
        hospitals_df = pd.read_csv(self.reference_dir / "unique_hospitals.csv")
        disease_codes_df = pd.read_csv(self.reference_dir / "unique_disease_codes.csv")

        self.data = ReferenceData(
            diseases=diseases_df,
            drugs=drugs_df,
            ingredients=ingredients_df,
            procedures=procedures_df,
            hospitals=hospitals_df,
            disease_codes=disease_codes_df
        )

        print(f"âœ… Loaded reference data:")
        print(f"  - Diseases: {len(diseases_df):,} records")
        print(f"  - Drugs: {len(drugs_df):,} records")
        print(f"  - Ingredients: {len(ingredients_df):,} records")
        print(f"  - Procedures: {len(procedures_df):,} records")
        print(f"  - Hospitals: {len(hospitals_df):,} records")
        print(f"  - Disease Codes: {len(disease_codes_df):,} records")

        return self.data

    def search_diseases(self, keyword: str, limit: int = 10) -> List[Dict]:
        """ì§ˆí™˜ëª… ê²€ìƒ‰"""
        if not self.data:
            self.load_all_data()

        # í‚¤ì›Œë“œë¡œ ê²€ìƒ‰ (ëŒ€ì†Œë¬¸ì ë¬´ì‹œ)
        mask = self.data.diseases['name'].str.contains(keyword, case=False, na=False)
        results = self.data.diseases[mask].head(limit)

        return results.to_dict('records')

    def search_drugs(self, keyword: str, limit: int = 10) -> List[Dict]:
        """ì•½ë¬¼ëª… ê²€ìƒ‰"""
        if not self.data:
            self.load_all_data()

        # ì•½ë¬¼ëª… ë˜ëŠ” ì„±ë¶„ëª…ì—ì„œ ê²€ìƒ‰
        name_mask = self.data.drugs['name'].str.contains(keyword, case=False, na=False)
        ingredient_mask = self.data.drugs['ingredients'].str.contains(keyword, case=False, na=False)
        mask = name_mask | ingredient_mask

        results = self.data.drugs[mask].head(limit)
        return results.to_dict('records')

    def search_procedures(self, keyword: str, limit: int = 10) -> List[Dict]:
        """ì˜ë£Œ í–‰ìœ„/ì²˜ì¹˜ ê²€ìƒ‰"""
        if not self.data:
            self.load_all_data()

        mask = self.data.procedures['name'].str.contains(keyword, case=False, na=False)
        results = self.data.procedures[mask].head(limit)

        return results.to_dict('records')

    def get_top_diseases(self, limit: int = 50) -> List[Dict]:
        """í™˜ì ìˆ˜ ê¸°ì¤€ ìƒìœ„ ì§ˆí™˜ë“¤"""
        if not self.data:
            self.load_all_data()

        return self.data.diseases.head(limit).to_dict('records')

    def get_top_drugs(self, limit: int = 50) -> List[Dict]:
        """ì²˜ë°© í™˜ì ìˆ˜ ê¸°ì¤€ ìƒìœ„ ì•½ë¬¼ë“¤"""
        if not self.data:
            self.load_all_data()

        return self.data.drugs.head(limit).to_dict('records')

    def validate_disease_name(self, disease_name: str) -> bool:
        """ì§ˆí™˜ëª…ì´ DBì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
        if not self.data:
            self.load_all_data()

        return disease_name in self.data.diseases['name'].values

    def validate_drug_name(self, drug_name: str) -> bool:
        """ì•½ë¬¼ëª…ì´ DBì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
        if not self.data:
            self.load_all_data()

        return drug_name in self.data.drugs['name'].values or \
               drug_name in self.data.drugs['ingredients'].values


class CriteriaType(Enum):
    """ì¡°ê±´ íƒ€ì… ì •ì˜"""
    AGE = "age"
    GENDER = "gender"
    DISEASE = "disease"
    DRUG = "drug"
    PROCEDURE = "procedure"
    VITAL_SIGNS = "vital_signs"
    PREGNANCY = "pregnancy"
    PERIOD = "period"
    CONSENT = "consent"


@dataclass
class ClinicalCriteria:
    """ì„ìƒì‹œí—˜ ì¡°ê±´ì„ ë‚˜íƒ€ë‚´ëŠ” ë°ì´í„° í´ë˜ìŠ¤"""
    criteria_type: CriteriaType
    description: str
    keywords: List[str] = field(default_factory=list)
    values: Dict[str, Any] = field(default_factory=dict)
    is_inclusion: bool = True  # True: ì„ ì •ì¡°ê±´, False: ì œì™¸ì¡°ê±´


class CriteriaAnalyzer:
    """ì„ìƒì‹œí—˜ ì„ ì •/ì œì™¸ ì¡°ê±´ ë¶„ì„ê¸°"""

    def __init__(self, reference_loader: ReferenceDataLoader):
        self.reference_loader = reference_loader

        # LLM ì„¤ì •
        self.llm_model = None
        self._setup_llm()

        # ê¸°ì¡´ íŒ¨í„´ë“¤ì€ fallbackìš©ìœ¼ë¡œ ìœ ì§€
        self.age_patterns = [
            r'ë§Œ?\s*(\d+)ì„¸?\s*ì´ìƒ',
            r'(\d+)ì„¸?\s*ì´ìƒ',
            r'ë§Œ?\s*(\d+)ì„¸?\s*[-~]?\s*ë§Œ?\s*(\d+)ì„¸?',
            r'ì„±ì¸',
            r'adult'
        ]

        self.gender_patterns = [
            r'ë‚¨ë…€',
            r'ë‚¨ì„±',
            r'ì—¬ì„±',
            r'male',
            r'female'
        ]

        self.vital_patterns = [
            r'í˜ˆì••.*?(\d+).*?mmHg',
            r'ìˆ˜ì¶•ê¸°.*?(\d+)',
            r'ì´ì™„ê¸°.*?(\d+)',
            r'MSSBP.*?(\d+)',
            r'MSDBP.*?(\d+)'
        ]

        self.pregnancy_patterns = [
            r'ì„ì‹ ',
            r'ìˆ˜ìœ ',
            r'ì„ì‹ ë¶€',
            r'ìˆ˜ìœ ë¶€',
            r'pregnant',
            r'pregnancy'
        ]

    def analyze_criteria_text(self, criteria_text: str, is_inclusion: bool = True) -> List[ClinicalCriteria]:
        """ì¡°ê±´ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ êµ¬ì¡°í™”ëœ ì¡°ê±´ë“¤ë¡œ ë³€í™˜"""
        criteria_list = []

        # ì¤„ ë‹¨ìœ„ë¡œ ë¶„ì„
        lines = criteria_text.strip().split('\n')

        for line in lines:
            line = line.strip()
            if not line or line.startswith('#') or line.startswith('//'):
                continue

            # ê° íƒ€ì…ë³„ ë¶„ì„
            criteria_list.extend(self._analyze_age_criteria(line, is_inclusion))
            criteria_list.extend(self._analyze_gender_criteria(line, is_inclusion))
            criteria_list.extend(self._analyze_disease_criteria(line, is_inclusion))
            criteria_list.extend(self._analyze_drug_criteria(line, is_inclusion))
            criteria_list.extend(self._analyze_vital_criteria(line, is_inclusion))
            criteria_list.extend(self._analyze_pregnancy_criteria(line, is_inclusion))

        return criteria_list

    def _analyze_age_criteria(self, text: str, is_inclusion: bool) -> List[ClinicalCriteria]:
        """ì—°ë ¹ ì¡°ê±´ ë¶„ì„"""
        criteria_list = []

        for pattern in self.age_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                if 'ì„±ì¸' in text or 'adult' in text.lower():
                    criteria_list.append(ClinicalCriteria(
                        criteria_type=CriteriaType.AGE,
                        description=text,
                        values={"min_age": 19, "max_age": 120},
                        is_inclusion=is_inclusion
                    ))
                elif len(matches[0]) == 2:  # ë²”ìœ„ (ì˜ˆ: 19-65ì„¸)
                    min_age, max_age = matches[0]
                    criteria_list.append(ClinicalCriteria(
                        criteria_type=CriteriaType.AGE,
                        description=text,
                        values={"min_age": int(min_age), "max_age": int(max_age)},
                        is_inclusion=is_inclusion
                    ))
                else:  # ìµœì†Œ ì—°ë ¹ (ì˜ˆ: 19ì„¸ ì´ìƒ)
                    age = int(matches[0])
                    criteria_list.append(ClinicalCriteria(
                        criteria_type=CriteriaType.AGE,
                        description=text,
                        values={"min_age": age, "max_age": 120},
                        is_inclusion=is_inclusion
                    ))
                break

        return criteria_list

    def _analyze_gender_criteria(self, text: str, is_inclusion: bool) -> List[ClinicalCriteria]:
        """ì„±ë³„ ì¡°ê±´ ë¶„ì„"""
        criteria_list = []

        for pattern in self.gender_patterns:
            if re.search(pattern, text, re.IGNORECASE):
                if 'ë‚¨ë…€' in text:
                    gender = "both"
                elif 'ë‚¨ì„±' in text or 'male' in text.lower():
                    gender = "male"
                elif 'ì—¬ì„±' in text or 'female' in text.lower():
                    gender = "female"
                else:
                    gender = "both"

                criteria_list.append(ClinicalCriteria(
                    criteria_type=CriteriaType.GENDER,
                    description=text,
                    values={"gender": gender},
                    is_inclusion=is_inclusion
                ))
                break

        return criteria_list

    def _analyze_disease_criteria(self, text: str, is_inclusion: bool) -> List[ClinicalCriteria]:
        """ì§ˆí™˜ ì¡°ê±´ ë¶„ì„"""
        criteria_list = []

        # ì°¸ì¡° ë°ì´í„°ì—ì„œ ì§ˆí™˜ëª… ë§¤ì¹­
        disease_keywords = []

        # ìƒìœ„ ì§ˆí™˜ë“¤ê³¼ ë§¤ì¹­
        top_diseases = self.reference_loader.get_top_diseases(limit=1000)
        for disease in top_diseases:
            disease_name = disease['name']
            # ê°„ë‹¨í•œ í‚¤ì›Œë“œ ì¶”ì¶œ (ê´„í˜¸ ì œê±°, í•µì‹¬ ë‹¨ì–´ë§Œ)
            clean_name = re.sub(r'\([^)]*\)', '', disease_name).strip()
            keywords = [word for word in clean_name.split() if len(word) > 1]

            for keyword in keywords:
                if keyword in text and len(keyword) > 2:
                    disease_keywords.append(keyword)

        if disease_keywords:
            criteria_list.append(ClinicalCriteria(
                criteria_type=CriteriaType.DISEASE,
                description=text,
                keywords=list(set(disease_keywords)),
                is_inclusion=is_inclusion
            ))

        return criteria_list

    def _analyze_drug_criteria(self, text: str, is_inclusion: bool) -> List[ClinicalCriteria]:
        """ì•½ë¬¼ ì¡°ê±´ ë¶„ì„"""
        criteria_list = []

        # ì•½ë¬¼ ê´€ë ¨ í‚¤ì›Œë“œ ì²´í¬
        drug_keywords = ['ì•½ë¬¼', 'íˆ¬ì—¬', 'ë³µìš©', 'ì¹˜ë£Œ', 'í•­ê³ í˜ˆì••ì œ', 'medication', 'drug', 'treatment']

        for keyword in drug_keywords:
            if keyword in text.lower():
                criteria_list.append(ClinicalCriteria(
                    criteria_type=CriteriaType.DRUG,
                    description=text,
                    keywords=[keyword],
                    is_inclusion=is_inclusion
                ))
                break

        return criteria_list

    def _analyze_vital_criteria(self, text: str, is_inclusion: bool) -> List[ClinicalCriteria]:
        """ìƒì²´ì§•í›„ ì¡°ê±´ ë¶„ì„"""
        criteria_list = []

        for pattern in self.vital_patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                values = {}
                if 'MSSBP' in text or 'ìˆ˜ì¶•ê¸°' in text:
                    values['systolic_bp'] = int(matches[0])
                elif 'MSDBP' in text or 'ì´ì™„ê¸°' in text:
                    values['diastolic_bp'] = int(matches[0])
                else:
                    values['blood_pressure'] = int(matches[0])

                criteria_list.append(ClinicalCriteria(
                    criteria_type=CriteriaType.VITAL_SIGNS,
                    description=text,
                    values=values,
                    is_inclusion=is_inclusion
                ))
                break

        return criteria_list

    def _analyze_pregnancy_criteria(self, text: str, is_inclusion: bool) -> List[ClinicalCriteria]:
        """ì„ì‹ /ìˆ˜ìœ  ì¡°ê±´ ë¶„ì„"""
        criteria_list = []

        for pattern in self.pregnancy_patterns:
            if re.search(pattern, text, re.IGNORECASE):
                criteria_list.append(ClinicalCriteria(
                    criteria_type=CriteriaType.PREGNANCY,
                    description=text,
                    keywords=[pattern],
                    is_inclusion=is_inclusion
                ))
                break

        return criteria_list

    def _setup_llm(self):
        """LLM ëª¨ë¸ ì„¤ì •"""
        try:
            # 1. í™˜ê²½ë³€ìˆ˜ì—ì„œ API í‚¤ í™•ì¸
            api_key = os.getenv("GEMINI_API_KEY")

            # 2. config.yamlì—ì„œ API í‚¤ í™•ì¸ (í™˜ê²½ë³€ìˆ˜ê°€ ì—†ìœ¼ë©´)
            if not api_key:
                try:
                    config_path = "config.yaml"
                    if os.path.exists(config_path):
                        with open(config_path, "r", encoding="utf-8") as f:
                            config = yaml.safe_load(f)
                            api_key = config.get("api_keys", {}).get("gemini_api_key")
                except Exception as e:
                    print(f"âš ï¸ config.yaml ì½ê¸° ì‹¤íŒ¨: {e}")

            if api_key and api_key != "YOUR_GEMINI_API_KEY_HERE":
                genai.configure(api_key=api_key)
                self.llm_model = genai.GenerativeModel('gemini-2.5-flash')
                print("âœ… Gemini LLM ëª¨ë¸ ì„¤ì • ì™„ë£Œ (gemini-2.5-flash)")
            else:
                print("âš ï¸ GEMINI_API_KEYê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ. ê·œì¹™ ê¸°ë°˜ ë¶„ì„ìœ¼ë¡œ fallback")
                self.llm_model = None
        except Exception as e:
            print(f"âš ï¸ LLM ì„¤ì • ì‹¤íŒ¨: {e}. ê·œì¹™ ê¸°ë°˜ ë¶„ì„ìœ¼ë¡œ fallback")
            self.llm_model = None

    def analyze_trial_criteria_with_llm(self, trial_name: str, inclusion_criteria: str, exclusion_criteria: str) -> Dict[str, List[ClinicalCriteria]]:
        """LLM ê¸°ë°˜ ê³ ë„í™”ëœ ì„ìƒì‹œí—˜ ì¡°ê±´ ë¶„ì„"""

        if not self.llm_model:
            print("âš ï¸ LLMì´ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. ê·œì¹™ ê¸°ë°˜ ë¶„ì„ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.")
            return self.analyze_trial_criteria(trial_name, inclusion_criteria, exclusion_criteria)

        try:
            # ì°¸ì¡° ë°ì´í„° ì •ë³´ ìƒì„±
            reference_summary = self._generate_reference_summary()

            # ê³ ë„í™”ëœ í”„ë¡¬í”„íŠ¸
            prompt = f"""
ë‹¹ì‹ ì€ ì„ìƒì‹œí—˜ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ì£¼ì–´ì§„ ì„ìƒì‹œí—˜ ì¡°ê±´ì„ ë¶„ì„í•˜ì—¬ êµ¬ì¡°í™”ëœ ì •ë³´ë¡œ ì¶”ì¶œí•´ì£¼ì„¸ìš”.

## ì„ìƒì‹œí—˜ ì •ë³´
**ì‹œí—˜ëª…**: {trial_name}

**í¬í•¨ ê¸°ì¤€ (Inclusion Criteria)**:
{inclusion_criteria}

**ì œì™¸ ê¸°ì¤€ (Exclusion Criteria)**:
{exclusion_criteria}

## ì‚¬ìš© ê°€ëŠ¥í•œ ì˜ë£Œ ë°ì´í„° ì°¸ì¡°
{reference_summary}

## ë¶„ì„ ìš”ì²­
ê° ì¡°ê±´ì„ ë‹¤ìŒ ì¹´í…Œê³ ë¦¬ë¡œ ë¶„ë¥˜í•˜ê³  êµ¬ì²´ì ì¸ ê°’ë“¤ì„ ì¶”ì¶œí•´ì£¼ì„¸ìš”:

1. **ì—°ë ¹ ì¡°ê±´**: ìµœì†Œ/ìµœëŒ€ ì—°ë ¹ (ìˆ«ì)
2. **ì„±ë³„ ì¡°ê±´**: male/female/both
3. **ì§ˆí™˜ ì¡°ê±´**: ì •í™•í•œ ì˜í•™ ìš©ì–´ (ì°¸ì¡° ë°ì´í„° ê¸°ì¤€)
4. **ì•½ë¬¼ ì¡°ê±´**: êµ¬ì²´ì ì¸ ì•½ë¬¼ëª… ë˜ëŠ” ì„±ë¶„ëª…
5. **ìƒì²´ì§•í›„ ì¡°ê±´**: ì¸¡ì •ê°’ê³¼ ë²”ìœ„ (í˜ˆì••, BMI, í˜ˆë‹¹ ë“±)
6. **ì„ì‹  ê´€ë ¨**: pregnancy/lactation ì—¬ë¶€
7. **ê¸°ê°„ ì¡°ê±´**: íŠ¹ì • ê¸°ê°„ (ê°œì›”, ë…„)

## ì¶œë ¥ í˜•ì‹ (JSON)
```json
{{
  "inclusion": [
    {{
      "type": "age",
      "description": "ë§Œ 19ì„¸ ì´ìƒ ì„±ì¸ ë‚¨ë…€",
      "values": {{"min_age": 19, "max_age": 120}},
      "keywords": ["ì„±ì¸", "19ì„¸"]
    }},
    {{
      "type": "disease",
      "description": "ê³ í˜ˆì•• ì§„ë‹¨ì„ ë°›ì€ í™˜ì",
      "values": {{}},
      "keywords": ["ê³ í˜ˆì••", "í˜ˆì••"]
    }},
    {{
      "type": "vital_signs",
      "description": "ìˆ˜ì¶•ê¸° í˜ˆì•• 140mmHg ì´ìƒ",
      "values": {{"parameter": "systolic_bp", "min": 140, "unit": "mmHg"}},
      "keywords": ["ìˆ˜ì¶•ê¸°", "í˜ˆì••", "140"]
    }}
  ],
  "exclusion": [
    {{
      "type": "disease",
      "description": "ìµœê·¼ 5ë…„ ì´ë‚´ ì•…ì„±ì¢…ì–‘ ë³‘ë ¥",
      "values": {{"period_months": 60}},
      "keywords": ["ì•…ì„±ì¢…ì–‘", "ì•…ì„±", "ì‹ ìƒë¬¼", "ì•”"]
    }},
    {{
      "type": "disease",
      "description": "ìµœê·¼ 12ê°œì›” ì´ë‚´ ì‹¬ê·¼ê²½ìƒ‰ ë˜ëŠ” ë‡Œì¡¸ì¤‘ ë³‘ë ¥",
      "values": {{"period_months": 12}},
      "keywords": ["ì‹¬ê·¼ê²½ìƒ‰", "ë‡Œì¡¸ì¤‘", "ì‹¬ê·¼", "ê²½ìƒ‰"]
    }}
  ]
}}
```

**ì¤‘ìš” ì§€ì¹¨**:
1. **ì •í™•í•œ ì§ˆë³‘ ë§¤í•‘**: ì…ë ¥ëœ ì§ˆë³‘ëª…ì„ ì •í™•íˆ ë¶„ì„í•˜ê³  ë§¤í•‘í•˜ì„¸ìš”
   - "ê³ í˜ˆì••" â†’ ["ê³ í˜ˆì••", "í˜ˆì••"] í‚¤ì›Œë“œ ì‚¬ìš©
   - "ë‹¹ë‡¨ë³‘" â†’ ["ë‹¹ë‡¨ë³‘", "ë‹¹ë‡¨"] í‚¤ì›Œë“œ ì‚¬ìš©
   - "ì•…ì„±ì¢…ì–‘" â†’ ["ì•…ì„±", "ì¢…ì–‘", "ì‹ ìƒë¬¼", "ì•”"] í‚¤ì›Œë“œ ì‚¬ìš©
2. **í¬í•¨/ì œì™¸ ì¡°ê±´ êµ¬ë¶„**: í¬í•¨ ì¡°ê±´ê³¼ ì œì™¸ ì¡°ê±´ì„ ëª…í™•íˆ êµ¬ë¶„í•˜ì„¸ìš”
3. **ìˆ«ì ê°’ ì •í™• ì¶”ì¶œ**: ì—°ë ¹, í˜ˆì••, ê¸°ê°„ ë“±ì˜ ìˆ«ìëŠ” ì •í™•íˆ ì¶”ì¶œí•˜ì„¸ìš”
4. **ê¸°ê°„ ë³€í™˜**: ê¸°ê°„ì€ ê°œì›” ë‹¨ìœ„ë¡œ ë³€í™˜í•˜ì„¸ìš” (5ë…„ = 60ê°œì›”)
5. **ì›ë³¸ í…ìŠ¤íŠ¸ ë³´ì¡´**: ê° ì¡°ê±´ì˜ ì›ë³¸ í…ìŠ¤íŠ¸ë¥¼ descriptionì— ë³´ì¡´í•˜ì„¸ìš”
6. **ê´€ë ¨ í‚¤ì›Œë“œ ì¶”ì¶œ**: ì‹¤ì œ ê²€ìƒ‰ì— ìœ ìš©í•œ í‚¤ì›Œë“œë“¤ì„ í¬í•¨í•˜ì„¸ìš”

JSON í˜•ì‹ìœ¼ë¡œë§Œ ë‹µë³€í•´ì£¼ì„¸ìš”.
"""

            # LLM í˜¸ì¶œ (ì•ˆì „ì„± ì²´í¬)
            if self.llm_model is None:
                print("âš ï¸  LLMì´ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. ê¸°ë³¸ ë¶„ì„ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.")
                return self._fallback_criteria_analysis(criteria_text)

            response = self.llm_model.generate_content(prompt)
            response_text = response.text.strip()

            # JSON íŒŒì‹± ì‹œë„
            if response_text.startswith('```json'):
                response_text = response_text.replace('```json', '').replace('```', '').strip()

            try:
                analysis_result = json.loads(response_text)
                print(f"âœ… LLM ë¶„ì„ ê²°ê³¼ (JSON íŒŒì‹± ì„±ê³µ):")
                print(f"í¬í•¨ ì¡°ê±´: {len(analysis_result.get('inclusion', []))}ê°œ")
                print(f"ì œì™¸ ì¡°ê±´: {len(analysis_result.get('exclusion', []))}ê°œ")

                # ì£¼ìš” í‚¤ì›Œë“œë“¤ í‘œì‹œ
                for category in ['inclusion', 'exclusion']:
                    if category in analysis_result:
                        for item in analysis_result[category]:
                            print(f"  [{category}] {item.get('type', 'unknown')}: {item.get('keywords', [])}")

                converted_result = self._convert_llm_result_to_criteria(analysis_result)
                print(f"âœ… ë³€í™˜ ì™„ë£Œ: í¬í•¨ {len(converted_result['inclusion'])}ê°œ, ì œì™¸ {len(converted_result['exclusion'])}ê°œ")
                return converted_result
            except json.JSONDecodeError as e:
                print(f"âš ï¸ LLM JSON íŒŒì‹± ì‹¤íŒ¨: {e}")
                print(f"ì‘ë‹µ: {response_text[:500]}...")
                # Fallback to rule-based analysis
                return self.analyze_trial_criteria(trial_name, inclusion_criteria, exclusion_criteria)

        except Exception as e:
            print(f"âš ï¸ LLM ë¶„ì„ ì‹¤íŒ¨: {e}")
            # Fallback to rule-based analysis
            return self.analyze_trial_criteria(trial_name, inclusion_criteria, exclusion_criteria)

    def _generate_reference_summary(self) -> str:
        """ì°¸ì¡° ë°ì´í„° ìš”ì•½ ìƒì„±"""
        try:
            summary = "### ë°ì´í„°ë² ì´ìŠ¤ ì°¸ì¡° ì •ë³´\n"

            if self.reference_loader.data:
                # ìƒìœ„ ì§ˆí™˜ë“¤
                top_diseases = self.reference_loader.get_top_diseases(limit=20)
                disease_examples = [d['name'] for d in top_diseases[:10]]
                summary += f"**ì£¼ìš” ì§ˆí™˜ëª…**: {', '.join(disease_examples[:5])}, ...\n"

                # ìƒìœ„ ì•½ë¬¼ë“¤
                top_drugs = self.reference_loader.get_top_drugs(limit=20)
                drug_examples = [d['name'] for d in top_drugs[:10]]
                summary += f"**ì£¼ìš” ì•½ë¬¼ëª…**: {', '.join(drug_examples[:5])}, ...\n"

                summary += "**ìƒì²´ì§•í›„**: í˜ˆì••(res_blood_pressure), BMI(res_bmi), ê³µë³µí˜ˆë‹¹(res_fasting_blood_suger), ì½œë ˆìŠ¤í…Œë¡¤ ë“±\n"

            return summary
        except:
            return "ì°¸ì¡° ë°ì´í„° ë¡œë“œ ì¤‘..."

    def _fallback_criteria_analysis(self, criteria_text: str) -> Dict:
        """LLM ì—†ì´ ê¸°ë³¸ ë¶„ì„ ìˆ˜í–‰"""
        print("ğŸ“Š ê¸°ë³¸ ì¡°ê±´ ë¶„ì„ ëª¨ë“œë¡œ ì‹¤í–‰...")

        # ê°„ë‹¨í•œ í‚¤ì›Œë“œ ê¸°ë°˜ ë¶„ì„
        criteria_text_lower = criteria_text.lower()

        basic_analysis = {
            "inclusion": [],
            "exclusion": [],
            "summary": "ê¸°ë³¸ ë¶„ì„ ëª¨ë“œ: LLM ê¸°ë°˜ ìƒì„¸ ë¶„ì„ì€ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
            "complexity": "ê¸°ë³¸ ë¶„ì„",
            "keywords": []
        }

        # ê¸°ë³¸ íŒ¨í„´ ë§¤ì¹­
        if any(word in criteria_text_lower for word in ["ë‚˜ì´", "age", "ì„¸"]):
            basic_analysis["inclusion"].append({
                "type": "age",
                "description": "ì—°ë ¹ ê´€ë ¨ ì¡°ê±´ (ìƒì„¸ ë¶„ì„ ë¶ˆê°€)",
                "keywords": ["ì—°ë ¹", "ë‚˜ì´"]
            })

        if any(word in criteria_text_lower for word in ["ì„±ë³„", "ë‚¨", "ì—¬", "gender"]):
            basic_analysis["inclusion"].append({
                "type": "gender",
                "description": "ì„±ë³„ ê´€ë ¨ ì¡°ê±´ (ìƒì„¸ ë¶„ì„ ë¶ˆê°€)",
                "keywords": ["ì„±ë³„"]
            })

        if any(word in criteria_text_lower for word in ["ì§ˆë³‘", "ì§ˆí™˜", "ë³‘ë ¥", "disease"]):
            basic_analysis["inclusion"].append({
                "type": "disease",
                "description": "ì§ˆí™˜ ê´€ë ¨ ì¡°ê±´ (ìƒì„¸ ë¶„ì„ ë¶ˆê°€)",
                "keywords": ["ì§ˆí™˜", "ì§ˆë³‘"]
            })

        return basic_analysis

    def _convert_llm_result_to_criteria(self, analysis_result: Dict) -> Dict[str, List[ClinicalCriteria]]:
        """LLM ë¶„ì„ ê²°ê³¼ë¥¼ ClinicalCriteria ê°ì²´ë¡œ ë³€í™˜"""
        criteria_map = {
            "inclusion": [],
            "exclusion": []
        }

        type_mapping = {
            "age": CriteriaType.AGE,
            "gender": CriteriaType.GENDER,
            "disease": CriteriaType.DISEASE,
            "drug": CriteriaType.DRUG,
            "vital_signs": CriteriaType.VITAL_SIGNS,
            "pregnancy": CriteriaType.PREGNANCY,
            "period": CriteriaType.PERIOD,
            "procedure": CriteriaType.PROCEDURE,
            "consent": CriteriaType.CONSENT
        }

        for category in ["inclusion", "exclusion"]:
            if category in analysis_result:
                for item in analysis_result[category]:
                    criteria_type = type_mapping.get(item.get("type"), CriteriaType.DISEASE)

                    criteria = ClinicalCriteria(
                        criteria_type=criteria_type,
                        description=item.get("description", ""),
                        values=item.get("values", {}),
                        keywords=item.get("keywords", []),
                        is_inclusion=(category == "inclusion")
                    )

                    criteria_map[category].append(criteria)

        return criteria_map

    def analyze_trial_criteria(self, trial_name: str, inclusion_criteria: str, exclusion_criteria: str) -> Dict[str, List[ClinicalCriteria]]:
        """ì „ì²´ ì„ìƒì‹œí—˜ ì¡°ê±´ ë¶„ì„"""
        print(f"\n=== {trial_name} ì¡°ê±´ ë¶„ì„ ===")

        inclusion_list = self.analyze_criteria_text(inclusion_criteria, is_inclusion=True)
        exclusion_list = self.analyze_criteria_text(exclusion_criteria, is_inclusion=False)

        print(f"ì„ ì • ì¡°ê±´: {len(inclusion_list)}ê°œ í•­ëª©")
        for criteria in inclusion_list:
            print(f"  âœ… [{criteria.criteria_type.value}] {criteria.description[:50]}...")

        print(f"ì œì™¸ ì¡°ê±´: {len(exclusion_list)}ê°œ í•­ëª©")
        for criteria in exclusion_list:
            print(f"  âŒ [{criteria.criteria_type.value}] {criteria.description[:50]}...")

        return {
            "inclusion": inclusion_list,
            "exclusion": exclusion_list
        }


@dataclass
class RecipeMatch:
    """ë ˆì‹œí”¼ ë§¤ì¹­ ê²°ê³¼"""
    recipe_name: str
    recipe_path: str
    match_score: float
    matched_criteria: List[ClinicalCriteria]
    required_parameters: Dict[str, Any]
    description: str


class RecipeSelector:
    """ì¡°ê±´ì— ë§ëŠ” ë ˆì‹œí”¼ ì„ íƒê¸°"""

    def __init__(self, recipes_dir: str = "recipes"):
        self.recipes_dir = Path(recipes_dir)
        self.recipe_metadata = {}
        self._load_recipe_metadata()

    def _load_recipe_metadata(self):
        """ëª¨ë“  ë ˆì‹œí”¼ì˜ ë©”íƒ€ë°ì´í„° ë¡œë“œ"""
        print("Loading recipe metadata...")

        for category_dir in ["pool", "profile"]:
            category_path = self.recipes_dir / category_dir
            if not category_path.exists():
                continue

            yaml_files = list(category_path.glob("*.yaml"))
            for yaml_file in yaml_files:
                try:
                    with open(yaml_file, 'r', encoding='utf-8') as f:
                        metadata = yaml.safe_load(f)
                        recipe_name = metadata.get('name', yaml_file.stem)
                        self.recipe_metadata[recipe_name] = {
                            'metadata': metadata,
                            'category': category_dir,
                            'path': yaml_file,
                            'sql_path': yaml_file.with_suffix('.sql')
                        }
                except Exception as e:
                    print(f"Error loading {yaml_file}: {e}")

        print(f"âœ… Loaded {len(self.recipe_metadata)} recipe metadata files")

    def select_recipes_for_criteria(self, analyzed_criteria: Dict[str, List[ClinicalCriteria]]) -> List[RecipeMatch]:
        """ë¶„ì„ëœ ì¡°ê±´ë“¤ì— ë§ëŠ” ë ˆì‹œí”¼ë“¤ ì„ íƒ"""
        matches = []

        inclusion_criteria = analyzed_criteria.get("inclusion", [])
        exclusion_criteria = analyzed_criteria.get("exclusion", [])

        # ê° ë ˆì‹œí”¼ì— ëŒ€í•´ ë§¤ì¹­ ì ìˆ˜ ê³„ì‚°
        for recipe_name, recipe_info in self.recipe_metadata.items():
            match_result = self._calculate_recipe_match(
                recipe_name, recipe_info, inclusion_criteria, exclusion_criteria
            )
            if match_result.match_score > 0:
                matches.append(match_result)

        # ë§¤ì¹­ ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬
        matches.sort(key=lambda x: x.match_score, reverse=True)
        return matches

    def _calculate_recipe_match(self, recipe_name: str, recipe_info: Dict,
                               inclusion_criteria: List[ClinicalCriteria],
                               exclusion_criteria: List[ClinicalCriteria]) -> RecipeMatch:
        """ê°œë³„ ë ˆì‹œí”¼ì˜ ë§¤ì¹­ ì ìˆ˜ ê³„ì‚°"""
        metadata = recipe_info['metadata']
        description = metadata.get('description', '')
        tags = metadata.get('tags', [])
        category = recipe_info['category']

        match_score = 0
        matched_criteria = []
        required_parameters = {}

        # ì¹´í…Œê³ ë¦¬ë³„ ê¸°ë³¸ ì ìˆ˜
        if category == "pool":
            match_score += 10  # í™˜ì ì¶”ì¶œìš© ë ˆì‹œí”¼ëŠ” ê¸°ë³¸ ì ìˆ˜

        # ì¡°ê±´ë³„ ë§¤ì¹­ ë¡œì§
        all_criteria = inclusion_criteria + exclusion_criteria

        for criteria in all_criteria:
            criteria_match_score = self._match_criteria_to_recipe(
                criteria, recipe_name, metadata, description, tags
            )

            if criteria_match_score > 0:
                match_score += criteria_match_score
                matched_criteria.append(criteria)

                # íŒŒë¼ë¯¸í„° ì¶”ì¶œ
                params = self._extract_parameters_for_criteria(criteria, metadata)
                required_parameters.update(params)

        return RecipeMatch(
            recipe_name=recipe_name,
            recipe_path=str(recipe_info['path']),
            match_score=match_score,
            matched_criteria=matched_criteria,
            required_parameters=required_parameters,
            description=description
        )

    def _match_criteria_to_recipe(self, criteria: ClinicalCriteria, recipe_name: str,
                                 metadata: Dict, description: str, tags: List[str]) -> float:
        """ê°œë³„ ì¡°ê±´ê³¼ ë ˆì‹œí”¼ ê°„ì˜ ë§¤ì¹­ ì ìˆ˜ ê³„ì‚°"""
        score = 0

        # ì¡°ê±´ íƒ€ì…ë³„ ë§¤ì¹­ ë¡œì§
        if criteria.criteria_type == CriteriaType.AGE:
            if any(keyword in recipe_name.lower() for keyword in ['age', 'gender', 'ì—°ë ¹']):
                score += 15
            if any(keyword in description.lower() for keyword in ['ì—°ë ¹', 'ë‚˜ì´', 'age']):
                score += 10

        elif criteria.criteria_type == CriteriaType.GENDER:
            if any(keyword in recipe_name.lower() for keyword in ['age', 'gender', 'ì„±ë³„']):
                score += 15
            if any(keyword in description.lower() for keyword in ['ì„±ë³„', 'ë‚¨ë…€', 'gender']):
                score += 10

        elif criteria.criteria_type == CriteriaType.DISEASE:
            if any(keyword in recipe_name.lower() for keyword in ['disease', 'diagnosis', 'ì§ˆí™˜', 'ì§„ë‹¨']):
                score += 20
            if any(keyword in description.lower() for keyword in ['ì§ˆí™˜', 'ì§„ë‹¨', 'ë³‘ë ¥', 'disease']):
                score += 15
            # í‚¤ì›Œë“œ ë§¤ì¹­
            for keyword in criteria.keywords:
                if keyword.lower() in description.lower() or keyword.lower() in recipe_name.lower():
                    score += 25

        elif criteria.criteria_type == CriteriaType.DRUG:
            if any(keyword in recipe_name.lower() for keyword in ['drug', 'medication', 'ì•½ë¬¼', 'ì²˜ë°©']):
                score += 20
            if any(keyword in description.lower() for keyword in ['ì•½ë¬¼', 'ì²˜ë°©', 'íˆ¬ì—¬', 'drug', 'medication']):
                score += 15

        elif criteria.criteria_type == CriteriaType.PROCEDURE:
            if any(keyword in recipe_name.lower() for keyword in ['procedure', 'treatment', 'ì²˜ì¹˜', 'ì¹˜ë£Œ']):
                score += 20
            if any(keyword in description.lower() for keyword in ['ì²˜ì¹˜', 'ì¹˜ë£Œ', 'ìˆ˜ìˆ ', 'procedure']):
                score += 15

        elif criteria.criteria_type == CriteriaType.VITAL_SIGNS:
            if any(keyword in recipe_name.lower() for keyword in ['vital', 'blood', 'í˜ˆì••', 'ìƒì²´']):
                score += 25
            if any(keyword in description.lower() for keyword in ['í˜ˆì••', 'ìƒì²´ì§•í›„', 'vital', 'blood pressure']):
                score += 20

        elif criteria.criteria_type == CriteriaType.PREGNANCY:
            if any(keyword in recipe_name.lower() for keyword in ['pregnancy', 'ì„ì‹ ', 'ìˆ˜ìœ ']):
                score += 30
            if any(keyword in description.lower() for keyword in ['ì„ì‹ ', 'ìˆ˜ìœ ', 'pregnancy']):
                score += 25

        # íŠ¹ë³„í•œ ë ˆì‹œí”¼ ë§¤ì¹­ ë¡œì§
        if criteria.criteria_type in [CriteriaType.DISEASE, CriteriaType.DRUG, CriteriaType.PROCEDURE]:
            # ë³µí•© ìŠ¤í¬ë¦¬ë‹ ë ˆì‹œí”¼ë“¤
            if 'screen' in recipe_name.lower() or 'criteria' in recipe_name.lower():
                score += 30
            if 'inclusion' in recipe_name.lower() or 'exclusion' in recipe_name.lower():
                score += 35

        return score

    def _extract_parameters_for_criteria(self, criteria: ClinicalCriteria, metadata: Dict) -> Dict[str, Any]:
        """ì¡°ê±´ì—ì„œ ë ˆì‹œí”¼ íŒŒë¼ë¯¸í„° ì¶”ì¶œ"""
        parameters = {}
        recipe_params = metadata.get('parameters', [])

        for param in recipe_params:
            param_name = param.get('name', '')
            param_type = param.get('type', 'string')

            # ì¡°ê±´ íƒ€ì…ë³„ íŒŒë¼ë¯¸í„° ë§¤í•‘
            if criteria.criteria_type == CriteriaType.AGE:
                if 'age' in param_name.lower():
                    if 'min' in param_name:
                        parameters[param_name] = criteria.values.get('min_age', 19)
                    elif 'max' in param_name:
                        parameters[param_name] = criteria.values.get('max_age', 120)

            elif criteria.criteria_type == CriteriaType.GENDER:
                if 'gender' in param_name.lower():
                    parameters[param_name] = criteria.values.get('gender', 'both')

            elif criteria.criteria_type == CriteriaType.DISEASE:
                if 'disease' in param_name.lower() or 'keyword' in param_name.lower():
                    if criteria.keywords:
                        parameters[param_name] = criteria.keywords[0]  # ì²« ë²ˆì§¸ í‚¤ì›Œë“œ ì‚¬ìš©

            elif criteria.criteria_type == CriteriaType.DRUG:
                if 'drug' in param_name.lower() or 'medication' in param_name.lower():
                    if criteria.keywords:
                        parameters[param_name] = criteria.keywords[0]

            elif criteria.criteria_type == CriteriaType.VITAL_SIGNS:
                if 'bp' in param_name.lower() or 'pressure' in param_name.lower():
                    if 'systolic_bp' in criteria.values:
                        parameters[param_name] = criteria.values['systolic_bp']
                    elif 'blood_pressure' in criteria.values:
                        parameters[param_name] = criteria.values['blood_pressure']

        return parameters

    def get_recommended_recipe_sequence(self, analyzed_criteria: Dict[str, List[ClinicalCriteria]]) -> List[RecipeMatch]:
        """ì„ìƒì‹œí—˜ ìŠ¤í¬ë¦¬ë‹ì— ìµœì í™”ëœ ë ˆì‹œí”¼ ì‹œí€€ìŠ¤ ìƒì„±"""
        matches = self.select_recipes_for_criteria(analyzed_criteria)

        # ì„ìƒì‹œí—˜ ìŠ¤í¬ë¦¬ë‹ ìµœì  ì¡°í•© (ì‹¤ìš©ì„± ìš°ì„ )
        priority_recipes = [
            'analyze_screened_patient_count',               # 1. ìŠ¤í¬ë¦¬ë‹ëœ ì´ í™˜ì ìˆ˜ â­
            'analyze_screened_gender_distribution',         # 2. ì„±ë³„ ë¶„í¬ â­
            'analyze_screened_regional_distribution',       # 3. ì§€ì—­ ë¶„í¬ â­
            'get_top_prescribed_ingredients_by_disease',    # 4. í˜„ì¬ ì¹˜ë£Œ ì•½ë¬¼ í˜„í™©
        ]

        sequence = []

        # 1. ìš°ì„ ìˆœìœ„ ë ˆì‹œí”¼ë“¤ì„ ìˆœì„œëŒ€ë¡œ ì¶”ê°€ (ì§ì ‘ ìƒì„±)
        for priority_recipe in priority_recipes:
            if priority_recipe in self.recipe_metadata:
                recipe_info = self.recipe_metadata[priority_recipe]
                match = RecipeMatch(
                    recipe_name=priority_recipe,
                    recipe_path=str(recipe_info['path']),
                    match_score=10,  # ìµœê³  ìš°ì„ ìˆœìœ„
                    matched_criteria=[],
                    required_parameters={},
                    description=recipe_info['metadata'].get('description', 'ì„¤ëª… ì—†ìŒ')
                )
                sequence.append(match)

        # 2. ë‚˜ë¨¸ì§€ ë†’ì€ ì ìˆ˜ ë ˆì‹œí”¼ë“¤ ì¶”ê°€ (ì¤‘ë³µ ì œê±°)
        existing_names = {match.recipe_name for match in sequence}
        remaining_matches = [m for m in matches if m.recipe_name not in existing_names]

        # ë³µì¡í•œ ìŠ¤í¬ë¦¬ë‹ ë ˆì‹œí”¼ëŠ” ì œì™¸í•˜ê³  ë¶„ì„ ìœ„ì£¼ë¡œ
        filtered_matches = []
        for match in remaining_matches:
            # ë„ˆë¬´ ë³µì¡í•œ ìŠ¤í¬ë¦¬ë‹ ë ˆì‹œí”¼ë“¤ ì œì™¸
            if not any(keyword in match.recipe_name.lower() for keyword in
                      ['inclusion_exclusion_list', 'sjogren', 'clinical_trial_candidates']):
                filtered_matches.append(match)

        sequence.extend(filtered_matches[:1])  # ì¶”ê°€ë¡œ 1ê°œë§Œ

        print(f"âœ… ì„ìƒì‹œí—˜ ë§ì¶¤í˜• ë ˆì‹œí”¼ ì‹œí€€ìŠ¤ ìƒì„±: {len(sequence)}ê°œ")
        for i, match in enumerate(sequence, 1):
            print(f"  {i}. {match.recipe_name}")

        return sequence


class ParameterExtractor:
    """ë™ì  íŒŒë¼ë¯¸í„° ìƒì„±ê¸° - ì¡°ê±´ê³¼ ë ˆì‹œí”¼ì—ì„œ ìµœì í™”ëœ íŒŒë¼ë¯¸í„° ì¶”ì¶œ"""

    def __init__(self, reference_loader: ReferenceDataLoader):
        self.reference_loader = reference_loader

        # ê¸°ë³¸ íŒŒë¼ë¯¸í„° ê°’ë“¤
        self.default_date_range = {
            "start_date": "2022-01-01",
            "end_date": "2024-12-31"
        }

    def extract_parameters_for_recipe(self, recipe_match: RecipeMatch,
                                    analyzed_criteria: Dict[str, List[ClinicalCriteria]]) -> Dict[str, Any]:
        """ë ˆì‹œí”¼ì™€ ì¡°ê±´ì— ë§ëŠ” íŒŒë¼ë¯¸í„° ìƒì„±"""

        # ë ˆì‹œí”¼ ë©”íƒ€ë°ì´í„°ì—ì„œ í•„ìš”í•œ íŒŒë¼ë¯¸í„° ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        yaml_path = Path(recipe_match.recipe_path)
        with open(yaml_path, 'r', encoding='utf-8') as f:
            metadata = yaml.safe_load(f)

        recipe_params = metadata.get('parameters', [])
        generated_params = {}

        # ê¸°ë³¸ ë‚ ì§œ íŒŒë¼ë¯¸í„° ì„¤ì •
        generated_params.update(self.default_date_range)

        # ê° íŒŒë¼ë¯¸í„°ì— ëŒ€í•´ ê°’ ìƒì„±
        for param in recipe_params:
            param_name = param.get('name', '')
            param_type = param.get('type', 'string')
            param_desc = param.get('description', '')
            param_default = param.get('default')

            # ì´ë¯¸ ê¸°ë³¸ê°’ì´ ìˆìœ¼ë©´ ì‚¬ìš©
            if param_name in generated_params:
                continue

            # ì¡°ê±´ ê¸°ë°˜ íŒŒë¼ë¯¸í„° ê°’ ìƒì„±
            param_value = self._generate_parameter_value(
                param_name, param_type, param_desc, param_default,
                analyzed_criteria
            )

            if param_value is not None:
                generated_params[param_name] = param_value
                print(f"  ğŸ“ {param_name}: {param_value}")

        print(f"âœ… ì´ {len(generated_params)}ê°œ íŒŒë¼ë¯¸í„° ìƒì„± ì™„ë£Œ")

        return generated_params

    def _generate_parameter_value(self, param_name: str, param_type: str,
                                param_desc: str, param_default: Any,
                                analyzed_criteria: Dict[str, List[ClinicalCriteria]]) -> Any:
        """ê°œë³„ íŒŒë¼ë¯¸í„° ê°’ ìƒì„±"""

        all_criteria = analyzed_criteria.get("inclusion", []) + analyzed_criteria.get("exclusion", [])

        # íŒŒë¼ë¯¸í„° ì´ë¦„ê³¼ ì„¤ëª…ì„ ê¸°ë°˜ìœ¼ë¡œ ë§¤ì¹­
        param_lower = param_name.lower()
        desc_lower = param_desc.lower()

        # íŠ¹ìˆ˜í•œ íŒŒë¼ë¯¸í„°ëª… ì§ì ‘ ë§¤í•‘ (ìš°ì„ ìˆœìœ„ ë†’ìŒ)
        if param_name == 'top_n':
            return 10
        elif param_name == 'disease_name_keyword' or param_name == 'disease_keyword':
            # í¬í•¨ ì¡°ê±´ì˜ ì§ˆí™˜ë§Œ ì„ íƒ
            inclusion_disease_criteria = [c for c in all_criteria if c.criteria_type == CriteriaType.DISEASE and c.is_inclusion]
            if inclusion_disease_criteria and inclusion_disease_criteria[0].keywords:
                return inclusion_disease_criteria[0].keywords[0]
            return "ê³ í˜ˆì••"
        elif 'drug' in param_name and 'ingredient' in param_name:
            # ì•½ë¬¼ ì„±ë¶„ íŒŒë¼ë¯¸í„° - ì„œë¡œ ë‹¤ë¥¸ ì•½ë¬¼ í• ë‹¹
            inclusion_drug_criteria = [c for c in all_criteria if c.criteria_type == CriteriaType.DRUG and c.is_inclusion]
            if inclusion_drug_criteria and inclusion_drug_criteria[0].keywords:
                keywords = inclusion_drug_criteria[0].keywords
                if 'drug1' in param_name and len(keywords) > 0:
                    return keywords[0]
                elif 'drug2' in param_name and len(keywords) > 1:
                    return keywords[1]
                elif 'drug2' in param_name:
                    return "ì•„ìŠ¤í”¼ë¦°"  # ë‘ ë²ˆì§¸ ì•½ë¬¼ ê¸°ë³¸ê°’
                return keywords[0]

            # ê¸°ë³¸ê°’ë“¤ì„ ë‹¤ë¥´ê²Œ ì„¤ì •
            if 'drug1' in param_name:
                return "í•­ê³ í˜ˆì••ì œ"
            elif 'drug2' in param_name:
                return "ì•„ìŠ¤í”¼ë¦°"
            return "í•­ê³ í˜ˆì••ì œ"

        # ì—°ë ¹ ê´€ë ¨ íŒŒë¼ë¯¸í„°
        if 'age' in param_lower or 'age' in desc_lower:
            age_criteria = [c for c in all_criteria if c.criteria_type == CriteriaType.AGE]
            if age_criteria:
                age_values = age_criteria[0].values
                if 'min' in param_lower:
                    return age_values.get('min_age', 19)
                elif 'max' in param_lower:
                    return age_values.get('max_age', 120)
                else:
                    return age_values.get('min_age', 19)

        # ì„±ë³„ ê´€ë ¨ íŒŒë¼ë¯¸í„°
        elif 'gender' in param_lower or 'gender' in desc_lower:
            gender_criteria = [c for c in all_criteria if c.criteria_type == CriteriaType.GENDER]
            if gender_criteria:
                return gender_criteria[0].values.get('gender', 'both')

        # ì§ˆí™˜ ê´€ë ¨ íŒŒë¼ë¯¸í„°
        elif any(keyword in param_lower for keyword in ['disease', 'keyword', 'condition']) or \
             any(keyword in desc_lower for keyword in ['ì§ˆí™˜', 'ì§„ë‹¨', 'ë³‘ëª…', 'disease']):

            # í¬í•¨ ê¸°ì¤€ ì§ˆí™˜ í‚¤ì›Œë“œ (inclusion_disease_keyword)
            if 'inclusion' in param_lower:
                inclusion_criteria = [c for c in all_criteria if c.criteria_type == CriteriaType.DISEASE and c.is_inclusion]
                if inclusion_criteria and inclusion_criteria[0].keywords:
                    return inclusion_criteria[0].keywords[0]
                return "ê³ í˜ˆì••"

            # ì œì™¸ ê¸°ì¤€ ì§ˆí™˜ í‚¤ì›Œë“œë“¤ (exclusion_disease_keywords) - ì‰¼í‘œë¡œ êµ¬ë¶„
            elif 'exclusion' in param_lower:
                exclusion_criteria = [c for c in all_criteria if c.criteria_type == CriteriaType.DISEASE and not c.is_inclusion]
                if exclusion_criteria:
                    all_keywords = []
                    for criterion in exclusion_criteria:
                        if criterion.keywords:
                            all_keywords.extend(criterion.keywords)
                    if all_keywords:
                        # ì¤‘ë³µ ì œê±°í•˜ê³  ì‰¼í‘œë¡œ ì—°ê²°
                        unique_keywords = list(set(all_keywords))
                        return ",".join(unique_keywords)
                # ê¸°ë³¸ ì œì™¸ ì¡°ê±´ë“¤
                return "ì•…ì„±ì¢…ì–‘,ì•…ì„±,ì‹ ìƒë¬¼,ì•”,ì‹¬ê·¼ê²½ìƒ‰,ë‡Œì¡¸ì¤‘"

            # ì¼ë°˜ ì§ˆí™˜ í‚¤ì›Œë“œ (í¬í•¨ ì¡°ê±´ ìš°ì„ )
            else:
                # í¬í•¨ ì¡°ê±´ì˜ ì§ˆí™˜ë§Œ ì„ íƒ
                inclusion_disease_criteria = [c for c in all_criteria if c.criteria_type == CriteriaType.DISEASE and c.is_inclusion]
                if inclusion_disease_criteria:
                    # í¬í•¨ ì¡°ê±´ì˜ ì²« ë²ˆì§¸ í‚¤ì›Œë“œ ì‚¬ìš©
                    if inclusion_disease_criteria[0].keywords:
                        return inclusion_disease_criteria[0].keywords[0]

                # í¬í•¨ ì¡°ê±´ì´ ì—†ìœ¼ë©´ ì „ì²´ì—ì„œ ì²« ë²ˆì§¸
                disease_criteria = [c for c in all_criteria if c.criteria_type == CriteriaType.DISEASE]
                if disease_criteria:
                    if disease_criteria[0].keywords:
                        return disease_criteria[0].keywords[0]

                # ê¸°ë³¸ê°’
                return "ê³ í˜ˆì••"

        # ì•½ë¬¼ ê´€ë ¨ íŒŒë¼ë¯¸í„°
        elif any(keyword in param_lower for keyword in ['drug', 'medication', 'ì•½ë¬¼']) or \
             any(keyword in desc_lower for keyword in ['ì•½ë¬¼', 'ì²˜ë°©', 'drug', 'medication']):

            # ì œì™¸ ê¸°ì¤€ ì•½ë¬¼ í‚¤ì›Œë“œë“¤ (exclusion_drug_keywords) - ì‰¼í‘œë¡œ êµ¬ë¶„
            if 'exclusion' in param_lower:
                exclusion_drug_criteria = [c for c in all_criteria if c.criteria_type == CriteriaType.DRUG and not c.is_inclusion]
                if exclusion_drug_criteria:
                    all_drug_keywords = []
                    for criterion in exclusion_drug_criteria:
                        if criterion.keywords:
                            all_drug_keywords.extend(criterion.keywords)
                    if all_drug_keywords:
                        # ì¤‘ë³µ ì œê±°í•˜ê³  ì‰¼í‘œë¡œ ì—°ê²°
                        unique_drug_keywords = list(set(all_drug_keywords))
                        return ",".join(unique_drug_keywords)
                # ê¸°ë³¸ ì œì™¸ ì•½ë¬¼ë“¤
                return "ì™€íŒŒë¦°,ì•„ìŠ¤í”¼ë¦°,ìŠ¤í…Œë¡œì´ë“œ"

            # ì¼ë°˜ ì•½ë¬¼ í‚¤ì›Œë“œ (í¬í•¨ ì¡°ê±´ ìš°ì„ )
            else:
                # í¬í•¨ ì¡°ê±´ì˜ ì•½ë¬¼ë§Œ ì„ íƒ
                inclusion_drug_criteria = [c for c in all_criteria if c.criteria_type == CriteriaType.DRUG and c.is_inclusion]
                if inclusion_drug_criteria:
                    if inclusion_drug_criteria[0].keywords:
                        return inclusion_drug_criteria[0].keywords[0]

                # í¬í•¨ ì¡°ê±´ì´ ì—†ìœ¼ë©´ ì „ì²´ì—ì„œ ì²« ë²ˆì§¸
                drug_criteria = [c for c in all_criteria if c.criteria_type == CriteriaType.DRUG]
                if drug_criteria:
                    if drug_criteria[0].keywords:
                        return drug_criteria[0].keywords[0]

                # ê¸°ë³¸ê°’
                return "í•­ê³ í˜ˆì••ì œ"

        # í˜ˆì•• ê´€ë ¨ íŒŒë¼ë¯¸í„°
        elif any(keyword in param_lower for keyword in ['bp', 'pressure', 'í˜ˆì••']) or \
             any(keyword in desc_lower for keyword in ['í˜ˆì••', 'blood pressure']):
            vital_criteria = [c for c in all_criteria if c.criteria_type == CriteriaType.VITAL_SIGNS]
            if vital_criteria:
                return vital_criteria[0].values.get('systolic_bp', 140)

        # ê¸°ê°„ ê´€ë ¨ íŒŒë¼ë¯¸í„°
        elif any(keyword in param_lower for keyword in ['period', 'duration', 'ê¸°ê°„']):
            return 90  # ê¸°ë³¸ 90ì¼

        # ìµœì†Œ/ìµœëŒ€ í™˜ììˆ˜ íŒŒë¼ë¯¸í„°
        elif 'patient' in param_lower and ('min' in param_lower or 'max' in param_lower):
            return 10 if 'min' in param_lower else 1000

        # íŠ¹ìˆ˜í•œ íŒŒë¼ë¯¸í„°ëª…ë“¤ ì²˜ë¦¬
        if 'top_n' in param_lower or 'limit' in param_lower:
            return 10  # ìˆ«ì ê¸°ë³¸ê°’

        if 'window' in param_lower and 'month' in param_lower:
            return 12  # ê¸°ë³¸ 12ê°œì›”

        if 'count' in param_lower or 'num' in param_lower:
            return 5  # ê¸°ë³¸ ê°œìˆ˜

        # ê¸°ë³¸ê°’ì´ ìˆìœ¼ë©´ ì‚¬ìš©
        if param_default is not None:
            return param_default

        # íƒ€ì…ë³„ ê¸°ë³¸ê°’
        if param_type == 'integer':
            return 10
        elif param_type == 'date':
            return self.default_date_range['start_date']
        else:
            return "ê³ í˜ˆì••"  # ê¸°ë³¸ í‚¤ì›Œë“œ


@dataclass
class QueryResult:
    """ì¿¼ë¦¬ ì‹¤í–‰ ê²°ê³¼"""
    recipe_name: str
    success: bool
    generated_sql: Optional[str] = None
    parameters: Optional[Dict[str, Any]] = None
    data: Optional[pd.DataFrame] = None
    error_message: Optional[str] = None
    execution_time: float = 0.0
    row_count: int = 0


class QueryExecutor:
    """SQL ì¿¼ë¦¬ ì‹¤í–‰ê¸° - ìƒì„±ëœ íŒŒë¼ë¯¸í„°ë¡œ SQL ì¿¼ë¦¬ ì‹¤í–‰"""

    def __init__(self):
        self.execution_history = []

    def generate_sql_from_recipe(self, recipe_match: RecipeMatch,
                               parameters: Dict[str, Any]) -> str:
        """ë ˆì‹œí”¼ì™€ íŒŒë¼ë¯¸í„°ë¡œ ì‹¤í–‰ ê°€ëŠ¥í•œ SQL ìƒì„±"""

        # SQL íŒŒì¼ ê²½ë¡œ
        sql_path = Path(recipe_match.recipe_path).with_suffix('.sql')

        if not sql_path.exists():
            raise FileNotFoundError(f"SQL file not found: {sql_path}")

        # SQL í…œí”Œë¦¿ ì½ê¸°
        with open(sql_path, 'r', encoding='utf-8') as f:
            sql_template = f.read()

        # Jinja2 í…œí”Œë¦¿ ë Œë”ë§ (ì•ˆì „ì„± ê°œì„ )
        from jinja2 import Environment, StrictUndefined, TemplateError

        # StrictUndefinedë¥¼ ì‚¬ìš©í•˜ì—¬ ëˆ„ë½ëœ ë³€ìˆ˜ ê°ì§€
        env = Environment(undefined=StrictUndefined)
        template = env.from_string(sql_template)

        try:
            # íŒŒë¼ë¯¸í„° ë§¤í•‘ ë¡œì§ ì ìš© (í˜¸í™˜ì„±ì„ ìœ„í•´)
            mapped_parameters = self._apply_parameter_mapping(sql_template, parameters)
            rendered_sql = template.render(**mapped_parameters)
            return rendered_sql

        except TemplateError as e:
            # Jinja2 ê´€ë ¨ ì˜¤ë¥˜ (ëˆ„ë½ëœ ë³€ìˆ˜, ë¬¸ë²• ì˜¤ë¥˜ ë“±)
            missing_vars = self._find_missing_template_variables(sql_template, parameters)
            if missing_vars:
                raise ValueError(f"Missing template variables: {missing_vars}. Available parameters: {list(parameters.keys())}")
            else:
                raise ValueError(f"Template syntax error: {e}")

        except Exception as e:
            raise ValueError(f"SQL template rendering failed: {e}")

    def _find_missing_template_variables(self, template_str: str, provided_params: Dict) -> List[str]:
        """í…œí”Œë¦¿ì—ì„œ ëˆ„ë½ëœ ë³€ìˆ˜ë“¤ì„ ì°¾ì•„ ë°˜í™˜"""
        import re

        # {{ variable }} íŒ¨í„´ìœ¼ë¡œ ë³€ìˆ˜ ì¶”ì¶œ
        template_vars = set(re.findall(r'\{\{\s*(\w+)', template_str))
        # {% if variable %} íŒ¨í„´ë„ ì¶”ì¶œ
        conditional_vars = set(re.findall(r'\{\%\s*if\s+(\w+)', template_str))

        all_template_vars = template_vars | conditional_vars
        provided_vars = set(provided_params.keys())

        missing_vars = all_template_vars - provided_vars
        return list(missing_vars)

    def _apply_parameter_mapping(self, template_str: str, parameters: Dict) -> Dict:
        """íŒŒë¼ë¯¸í„° ë§¤í•‘ ë¡œì§ - í˜¸í™˜ì„±ì„ ìœ„í•´ ëˆ„ë½ëœ íŒŒë¼ë¯¸í„°ë¥¼ ìë™ ë§¤í•‘"""
        mapped_params = parameters.copy()

        # disease_code_prefixê°€ í•„ìš”í•˜ì§€ë§Œ ì—†ëŠ” ê²½ìš° disease_name_keywordë¡œ ë§¤í•‘
        if 'disease_code_prefix' in template_str and 'disease_code_prefix' not in mapped_params:
            if 'disease_name_keyword' in mapped_params:
                mapped_params['disease_code_prefix'] = mapped_params['disease_name_keyword']
                print(f"   ğŸ“ íŒŒë¼ë¯¸í„° ë§¤í•‘: disease_name_keyword -> disease_code_prefix")

        # ë°˜ëŒ€ì˜ ê²½ìš°ë„ ì²˜ë¦¬
        if 'disease_name_keyword' in template_str and 'disease_name_keyword' not in mapped_params:
            if 'disease_code_prefix' in mapped_params:
                mapped_params['disease_name_keyword'] = mapped_params['disease_code_prefix']
                print(f"   ğŸ“ íŒŒë¼ë¯¸í„° ë§¤í•‘: disease_code_prefix -> disease_name_keyword")

        # ê¸°íƒ€ ì¼ë°˜ì ì¸ ë§¤í•‘ë“¤
        parameter_mappings = {
            'limit': 'top_n',
            'top_n': 'limit',
            'disease_keyword': 'disease_name_keyword',
            'disease_name_keyword': 'disease_keyword',
            'target_ingredient': 'drug_ingredient',
            'drug_ingredient': 'target_ingredient'
        }

        # target_ingredientê°€ ëˆ„ë½ëœ ê²½ìš° ë¹ˆ ë¬¸ìì—´ë¡œ ì„¤ì • (ì „ì²´ ì„±ë¶„ ë¶„ì„)
        if 'target_ingredient' in template_str and 'target_ingredient' not in mapped_params:
            mapped_params['target_ingredient'] = ''
            print(f"   ğŸ“ íŒŒë¼ë¯¸í„° ê¸°ë³¸ê°’ ì„¤ì •: target_ingredient = '' (ì „ì²´ ì„±ë¶„ ë¶„ì„)")

        for template_param, source_param in parameter_mappings.items():
            if template_param in template_str and template_param not in mapped_params:
                if source_param in mapped_params:
                    mapped_params[template_param] = mapped_params[source_param]
                    print(f"   ğŸ“ íŒŒë¼ë¯¸í„° ë§¤í•‘: {source_param} -> {template_param}")

        return mapped_params

    def execute_recipe_sequence(self, recipe_sequence: List[RecipeMatch],
                              parameter_extractor: ParameterExtractor,
                              analyzed_criteria: Dict[str, List[ClinicalCriteria]],
                              dry_run: bool = True,
                              override_parameters: Optional[Dict[str, Dict]] = None) -> List[QueryResult]:
        """ë ˆì‹œí”¼ ì‹œí€€ìŠ¤ ì‹¤í–‰"""

        results = []

        for recipe_match in recipe_sequence:
            print(f"\nğŸ”„ ì‹¤í–‰ì¤‘: {recipe_match.recipe_name}")

            try:
                # íŒŒë¼ë¯¸í„° ìƒì„± (overrideê°€ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©)
                if override_parameters and recipe_match.recipe_name in override_parameters:
                    parameters = override_parameters[recipe_match.recipe_name]
                    print(f"ğŸ¯ ìµœì í™”ëœ íŒŒë¼ë¯¸í„° ì‚¬ìš©")
                else:
                    parameters = parameter_extractor.extract_parameters_for_recipe(
                        recipe_match, analyzed_criteria
                    )

                print(f"ğŸ“ ìƒì„±ëœ íŒŒë¼ë¯¸í„°: {parameters}")

                # SQL ìƒì„±
                sql_query = self.generate_sql_from_recipe(recipe_match, parameters)

                if dry_run:
                    # Dry run - SQLë§Œ ìƒì„±í•˜ê³  ì‹¤í–‰í•˜ì§€ ì•ŠìŒ
                    result = QueryResult(
                        recipe_name=recipe_match.recipe_name,
                        success=True,
                        generated_sql=sql_query,
                        parameters=parameters,
                        error_message=None,
                        execution_time=0.0
                    )
                    print(f"âœ… SQL ìƒì„± ì„±ê³µ (Dry Run)")
                    print(f"ğŸ” ìƒì„±ëœ SQL (ì²« 200ì):\n{sql_query[:200]}...")

                else:
                    # ì‹¤ì œ ì‹¤í–‰ì€ ì—¬ê¸°ì— DB ì—°ê²° ë¡œì§ ì¶”ê°€
                    # result = self._execute_sql(sql_query)
                    result = QueryResult(
                        recipe_name=recipe_match.recipe_name,
                        success=True,
                        generated_sql=sql_query,
                        parameters=parameters,
                        error_message="ì‹¤ì œ DB ì‹¤í–‰ ë¯¸êµ¬í˜„",
                        execution_time=0.0
                    )

                results.append(result)

            except Exception as e:
                print(f"âŒ ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}")
                result = QueryResult(
                    recipe_name=recipe_match.recipe_name,
                    success=False,
                    error_message=str(e),
                    execution_time=0.0
                )
                results.append(result)

        return results

    def _execute_sql(self, sql_query: str) -> QueryResult:
        """ì‹¤ì œ SQL ì‹¤í–‰ (DB ì—°ê²° í•„ìš”)"""
        # TODO: ì‹¤ì œ DB ì—°ê²° ë° ì¿¼ë¦¬ ì‹¤í–‰ ë¡œì§ êµ¬í˜„
        # ì˜ˆ: Spark SQL, PostgreSQL, etc.
        pass


class ClinicalTrialAgent:
    """ì„ìƒì‹œí—˜ ìŠ¤í¬ë¦¬ë‹ ìë™í™” ë©”ì¸ ì—ì´ì „íŠ¸"""

    def __init__(self):
        print("ğŸš€ Clinical Trial Agent ì´ˆê¸°í™” ì¤‘...")

        # ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™”
        self.reference_loader = ReferenceDataLoader()
        self.reference_loader.load_all_data()

        self.criteria_analyzer = CriteriaAnalyzer(self.reference_loader)
        self.recipe_selector = RecipeSelector()
        self.parameter_extractor = ParameterExtractor(self.reference_loader)
        self.query_executor = QueryExecutor()

        # ì¶”ê°€ ë¶„ì„ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        self.result_analyzer = ScreeningResultAnalyzer(self)

        print("âœ… Clinical Trial Agent ì¤€ë¹„ ì™„ë£Œ!")

    def run_clinical_trial_screening(self, trial_name: str,
                                   inclusion_criteria: str,
                                   exclusion_criteria: str,
                                   dry_run: bool = True) -> Dict[str, Any]:
        """ì „ì²´ ì„ìƒì‹œí—˜ ìŠ¤í¬ë¦¬ë‹ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰"""

        print(f"\nğŸ¯ ì„ìƒì‹œí—˜ ìŠ¤í¬ë¦¬ë‹ ì‹œì‘: {trial_name}")

        # 1. ì¡°ê±´ ë¶„ì„ (LLM ê¸°ë°˜ ê³ ë„í™”)
        print("\n1ï¸âƒ£ ì¡°ê±´ ë¶„ì„ ì¤‘...")
        analyzed_criteria = self.criteria_analyzer.analyze_trial_criteria_with_llm(
            trial_name, inclusion_criteria, exclusion_criteria
        )

        # 2. ë ˆì‹œí”¼ ì„ íƒ
        print("\n2ï¸âƒ£ ì í•©í•œ ë ˆì‹œí”¼ ì„ íƒ ì¤‘...")
        recipe_sequence = self.recipe_selector.get_recommended_recipe_sequence(analyzed_criteria)

        print(f"ì„ íƒëœ ë ˆì‹œí”¼ ìˆ˜: {len(recipe_sequence)}")
        for i, recipe in enumerate(recipe_sequence, 1):
            category = "í™˜ìì¶”ì¶œ" if "pool" in recipe.recipe_path else "ë¶„ì„"
            print(f"  {i}. [{category}] {recipe.recipe_name} (ì ìˆ˜: {recipe.match_score})")

        # 3. íŒŒë¼ë¯¸í„° ìƒì„± ë° ì¿¼ë¦¬ ì‹¤í–‰
        print("\n3ï¸âƒ£ ì¿¼ë¦¬ ìƒì„± ë° ì‹¤í–‰ ì¤‘...")
        execution_results = self.query_executor.execute_recipe_sequence(
            recipe_sequence, self.parameter_extractor, analyzed_criteria, dry_run=dry_run
        )

        # 4. ê²°ê³¼ ì •ë¦¬
        success_count = sum(1 for r in execution_results if r.success)

        print(f"\nğŸ‰ ìŠ¤í¬ë¦¬ë‹ ì™„ë£Œ!")
        print(f"ì´ {len(execution_results)}ê°œ ë ˆì‹œí”¼ ì¤‘ {success_count}ê°œ ì„±ê³µ")

        return {
            "trial_name": trial_name,
            "analyzed_criteria": analyzed_criteria,
            "selected_recipes": recipe_sequence,
            "execution_results": execution_results,
            "success_rate": success_count / len(execution_results) if execution_results else 0
        }

    def run_comprehensive_clinical_analysis(self, trial_name: str,
                                          inclusion_criteria: str,
                                          exclusion_criteria: str,
                                          dry_run: bool = True) -> Dict[str, Any]:
        """ìŠ¤í¬ë¦¬ë‹ + LLM ê¸°ë°˜ ì¶”ê°€ ë¶„ì„ì„ í†µí•©í•œ ì¢…í•© ì„ìƒ ë¶„ì„"""

        print(f"\nğŸ”¬ ì¢…í•© ì„ìƒ ë¶„ì„ ì‹œì‘: {trial_name}")
        print("=" * 60)

        # 1ë‹¨ê³„: ê¸°ë³¸ ìŠ¤í¬ë¦¬ë‹ ì‹¤í–‰
        print("1ï¸âƒ£ 1ë‹¨ê³„: ê¸°ë³¸ ì„ìƒì‹œí—˜ ìŠ¤í¬ë¦¬ë‹ ì‹¤í–‰")
        screening_result = self.run_clinical_trial_screening(
            trial_name, inclusion_criteria, exclusion_criteria, dry_run
        )

        # ìŠ¤í¬ë¦¬ë‹ ì‹¤íŒ¨ ì‹œ ì¢…ë£Œ
        if screening_result['success_rate'] == 0:
            print("âŒ ìŠ¤í¬ë¦¬ë‹ ì‹¤íŒ¨ë¡œ ì¶”ê°€ ë¶„ì„ì„ ì§„í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return {
                "trial_name": trial_name,
                "screening_result": screening_result,
                "additional_analysis": None,
                "overall_success": False
            }

        print(f"âœ… ìŠ¤í¬ë¦¬ë‹ ì™„ë£Œ (ì„±ê³µë¥ : {screening_result['success_rate']:.1%})")

        # 2ë‹¨ê³„: LLM ê¸°ë°˜ ì¶”ê°€ ë¶„ì„
        print("\n2ï¸âƒ£ 2ë‹¨ê³„: LLM ê¸°ë°˜ ì¶”ê°€ ë¶„ì„ ì‹¤í–‰")
        try:
            additional_analysis = self.result_analyzer.analyze_screening_results(
                screening_result['execution_results'],
                screening_result['analyzed_criteria'],
                trial_name
            )

            print("âœ… ì¶”ê°€ ë¶„ì„ ì™„ë£Œ")

            # 3ë‹¨ê³„: ì¢…í•© ê²°ê³¼ ìƒì„±
            print("\n3ï¸âƒ£ 3ë‹¨ê³„: ì¢…í•© ê²°ê³¼ ë¦¬í¬íŠ¸ ìƒì„±")
            comprehensive_result = self._generate_comprehensive_report(
                screening_result, additional_analysis, trial_name
            )

            return comprehensive_result

        except Exception as e:
            print(f"âŒ ì¶”ê°€ ë¶„ì„ ì‹¤íŒ¨: {e}")
            return {
                "trial_name": trial_name,
                "screening_result": screening_result,
                "additional_analysis": None,
                "overall_success": False,
                "error": str(e)
            }

    def _generate_comprehensive_report(self, screening_result: Dict,
                                     additional_analysis: Dict,
                                     trial_name: str) -> Dict[str, Any]:
        """ì¢…í•© ë¶„ì„ ê²°ê³¼ ë¦¬í¬íŠ¸ ìƒì„±"""

        # ì „ì²´ ì„±ê³µë¥  ê³„ì‚°
        screening_success = screening_result['success_rate']
        additional_success_count = sum(1 for r in additional_analysis['execution_results'] if r.success)
        additional_total = len(additional_analysis['execution_results'])
        additional_success_rate = additional_success_count / additional_total if additional_total > 0 else 0

        overall_success = screening_success > 0 and additional_success_rate > 0

        # ì‹¤í–‰ëœ ëª¨ë“  ë ˆì‹œí”¼ í†µí•©
        all_executed_recipes = []
        all_executed_recipes.extend(screening_result['execution_results'])
        all_executed_recipes.extend(additional_analysis['execution_results'])

        # ì „ì²´ ì„±ê³µë¥  ê³„ì‚°
        total_success_count = sum(1 for r in all_executed_recipes if r.success)
        overall_success_rate = total_success_count / len(all_executed_recipes) if all_executed_recipes else 0

        # LLM ì¸ì‚¬ì´íŠ¸ ì •ë¦¬
        llm_insights = {
            'clinical_significance': additional_analysis['llm_analysis'].get('clinical_significance', ''),
            'recommended_analyses': additional_analysis['llm_analysis'].get('recommended_analyses', []),
            'data_gaps': additional_analysis['llm_analysis'].get('data_gaps', []),
            'next_steps': additional_analysis['llm_analysis'].get('next_steps', '')
        }

        print(f"ğŸ“Š ì¢…í•© ê²°ê³¼:")
        print(f"   - ìŠ¤í¬ë¦¬ë‹ ì„±ê³µë¥ : {screening_success:.1%}")
        print(f"   - ì¶”ê°€ ë¶„ì„ ì„±ê³µë¥ : {additional_success_rate:.1%}")
        print(f"   - ì „ì²´ ì„±ê³µë¥ : {overall_success_rate:.1%}")
        print(f"   - ì´ ì‹¤í–‰ ë ˆì‹œí”¼: {len(all_executed_recipes)}ê°œ")
        print(f"   - LLM ì¶”ì²œ ë¶„ì„: {len(additional_analysis['llm_analysis'].get('recommended_analyses', []))}ê°œ")

        return {
            "trial_name": trial_name,
            "overall_success": overall_success,
            "overall_success_rate": overall_success_rate,  # ì¶”ê°€
            "screening_result": screening_result,
            "additional_analysis": additional_analysis,
            "performance_summary": {
                "screening_success_rate": screening_success,
                "additional_analysis_success_rate": additional_success_rate,
                "total_recipes_executed": len(all_executed_recipes),
                "successful_recipes": total_success_count
            },
            "llm_insights": llm_insights,
            "all_executed_recipes": all_executed_recipes
        }


# í…ŒìŠ¤íŠ¸ ì½”ë“œ
if __name__ == "__main__":

    # í†µí•© ClinicalTrialAgent í…ŒìŠ¤íŠ¸
    print("=" * 60)
    print("ğŸ¥ ì„ìƒì‹œí—˜ ìŠ¤í¬ë¦¬ë‹ ìë™í™” ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸")
    print("=" * 60)

    # ì—ì´ì „íŠ¸ ì´ˆê¸°í™”
    agent = ClinicalTrialAgent()

    # ì„ìƒì‹œí—˜ ì˜ˆì‹œ ì¡°ê±´ë“¤
    trial_name = "ê³ í˜ˆì•• ì‹ ì•½ ì„ìƒì‹œí—˜"

    inclusion_criteria = """
    ë§Œ 19ì„¸ ì´ìƒ ì„±ì¸ ë‚¨ë…€
    Visit 1 ê¸°ì¤€ í‰ê·  ì¢Œìœ„ ìˆ˜ì¶•ê¸° í˜ˆì••ì´ 140-180 mmHg ë²”ìœ„
    í•­ê³ í˜ˆì••ì œ ë³µìš© ì¤‘ì¸ ê²½ìš°, ì‹œí—˜ìì˜ íŒë‹¨ì— ë”°ë¼ ì¹˜ë£Œ ì¤‘ë‹¨ì´ ê°€ëŠ¥í•œ í™˜ì
    ì—¬ì„± ëŒ€ìƒìì˜ ê²½ìš° í”¼ì„ ì¡°ê±´ ì¶©ì¡±
    ì‹œí—˜ ëª©ì Â·ë‚´ìš© ì„¤ëª…ì„ ë“£ê³  ìë°œì  ì„œë©´ ë™ì˜ë¥¼ í•œ í™˜ì
    """

    exclusion_criteria = """
    Visit 1 ë˜ëŠ” Visit 2ì—ì„œ MSSBP â‰¥ 180 mmHg ë˜ëŠ” MSDBP â‰¥ 110 mmHg
    ìµœê·¼ 5ë…„ ì´ë‚´ ì•…ì„±ì¢…ì–‘ ë³‘ë ¥
    ìµœê·¼ 12ê°œì›” ì´ë‚´ ì‹¬ê·¼ê²½ìƒ‰ ë˜ëŠ” ë‡Œì¡¸ì¤‘ ë³‘ë ¥
    ì„ì‹ ë¶€ ë˜ëŠ” ìˆ˜ìœ ë¶€
    ì•½ë¬¼ ë˜ëŠ” ì•Œì½”ì˜¬ ë‚¨ìš© ë³‘ë ¥
    ì‹œí—˜ì•½ ì„±ë¶„ì— ê³¼ë¯¼ì¦ ê¸°ì™•ë ¥
    """

    # ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
    result = agent.run_clinical_trial_screening(
        trial_name=trial_name,
        inclusion_criteria=inclusion_criteria,
        exclusion_criteria=exclusion_criteria,
        dry_run=True  # SQL ìƒì„±ë§Œ, ì‹¤ì œ ì‹¤í–‰ ì•ˆí•¨
    )

    # ê²°ê³¼ ìš”ì•½
    print("\n" + "=" * 60)
    print("ğŸ“Š ìµœì¢… ê²°ê³¼ ìš”ì•½")
    print("=" * 60)
    print(f"ì„ìƒì‹œí—˜ëª…: {result['trial_name']}")
    print(f"ì„±ê³µë¥ : {result['success_rate']:.1%}")
    print(f"ì‹¤í–‰ëœ ë ˆì‹œí”¼: {len(result['execution_results'])}ê°œ")

    print("\nì‹¤í–‰ ê²°ê³¼:")
    for i, exec_result in enumerate(result['execution_results'], 1):
        status = "âœ… ì„±ê³µ" if exec_result.success else "âŒ ì‹¤íŒ¨"
        print(f"  {i}. {exec_result.recipe_name}: {status}")
        if exec_result.error_message:
            print(f"     ì˜¤ë¥˜: {exec_result.error_message}")

    print("\nğŸ¯ Phase 2 êµ¬í˜„ ì™„ë£Œ: ì„ìƒì‹œí—˜ ìŠ¤í¬ë¦¬ë‹ ìë™í™” ì‹œìŠ¤í…œì´ ì„±ê³µì ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤!")


class ScreeningResultAnalyzer:
    """ìŠ¤í¬ë¦¬ë‹ ê²°ê³¼ ê¸°ë°˜ LLM ì¶”ê°€ ë¶„ì„ ì¶”ì²œ ë° ì‹¤í–‰ ì‹œìŠ¤í…œ"""

    def __init__(self, clinical_trial_agent: ClinicalTrialAgent):
        self.agent = clinical_trial_agent
        self.llm_model = self.agent.criteria_analyzer.llm_model

    def _is_llm_available(self) -> bool:
        """LLM ëª¨ë¸ì´ ì‚¬ìš© ê°€ëŠ¥í•œì§€ í™•ì¸"""
        return self.llm_model is not None

    def analyze_screening_results(self, screening_results: List[QueryResult], analyzed_criteria: Dict, trial_name: str = "") -> Dict:
        """ìŠ¤í¬ë¦¬ë‹ ê²°ê³¼ë¥¼ LLMìœ¼ë¡œ ë¶„ì„í•˜ê³  ì¶”ê°€ ë¶„ì„ì„ ì¶”ì²œ"""

        if not self._is_llm_available():
            print("âš ï¸  LLMì´ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. ê¸°ë³¸ ë¶„ì„ë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤.")
            return self._fallback_analysis(screening_results, analyzed_criteria, trial_name)

        print("ğŸ¤– LLM ê¸°ë°˜ ìŠ¤í¬ë¦¬ë‹ ê²°ê³¼ ë¶„ì„ ì‹œì‘...")

        # 1. ìŠ¤í¬ë¦¬ë‹ ê²°ê³¼ ìš”ì•½
        screening_summary = self._extract_screening_summary(screening_results)

        # 2. LLMì„ í†µí•œ ì¢…í•©ì  ë¶„ì„ ë° ì¶”ì²œ
        try:
            llm_analysis = self._llm_comprehensive_analysis(
                screening_summary, analyzed_criteria, trial_name
            )
        except Exception as e:
            print(f"âš ï¸  LLM ë¶„ì„ ì‹¤íŒ¨: {e}")
            return self._fallback_analysis(screening_results, analyzed_criteria, trial_name)

        # 3. LLMì´ ì¶”ì²œí•œ ë¶„ì„ì„ ìœ„í•œ ìµœì  ë ˆì‹œí”¼ ì„ íƒ
        selected_recipes = self._llm_select_optimal_recipes(
            llm_analysis['recommended_analyses'], screening_summary
        )

        # 4. LLM ê¸°ë°˜ íŒŒë¼ë¯¸í„° ìµœì í™” ë° ì‹¤í–‰
        execution_results = self._execute_llm_optimized_analyses(
            selected_recipes, analyzed_criteria, llm_analysis
        )

        return {
            'screening_summary': screening_summary,
            'llm_analysis': llm_analysis,
            'selected_recipes': selected_recipes,
            'execution_results': execution_results
        }

    def _extract_screening_summary(self, screening_results: List[QueryResult]) -> Dict:
        """ìŠ¤í¬ë¦¬ë‹ ê²°ê³¼ ìš”ì•½"""
        summary = {
            'total_recipes': len(screening_results),
            'successful_recipes': [r.recipe_name for r in screening_results if r.success],
            'failed_recipes': [r.recipe_name for r in screening_results if not r.success],
            'key_parameters': {},
            'executed_recipe_types': []
        }

        for result in screening_results:
            if result.success:
                if result.parameters:
                    summary['key_parameters'].update(result.parameters)
                summary['executed_recipe_types'].append(result.recipe_name)

        return summary

    def _llm_comprehensive_analysis(self, screening_summary: Dict, analyzed_criteria: Dict, trial_name: str) -> Dict:
        """LLMì„ í†µí•œ ì¢…í•©ì  ë¶„ì„ ë° ì¶”ì²œ"""

        prompt = f"""
ë‹¹ì‹ ì€ ì„ìƒì‹œí—˜ ë°ì´í„° ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ìŠ¤í¬ë¦¬ë‹ì´ ì™„ë£Œëœ ì„ìƒì‹œí—˜ì— ëŒ€í•´ ì¶”ê°€ë¡œ í•„ìš”í•œ ë¶„ì„ì„ ì¶”ì²œí•´ì£¼ì„¸ìš”.

## ì„ìƒì‹œí—˜ ì •ë³´:
- ì„ìƒì‹œí—˜ëª…: {trial_name}
- ë¶„ì„ëœ ì¡°ê±´: {analyzed_criteria}

## ì™„ë£Œëœ ìŠ¤í¬ë¦¬ë‹ ê²°ê³¼:
- ì‹¤í–‰ëœ ë ˆì‹œí”¼: {screening_summary['successful_recipes']}
- ì£¼ìš” íŒŒë¼ë¯¸í„°: {screening_summary['key_parameters']}

## ë¶„ì„ ìš”ì²­:
1. **ì„ìƒì  ì˜ì˜ ë¶„ì„**: ì´ ìŠ¤í¬ë¦¬ë‹ ê²°ê³¼ê°€ ì„ìƒì‹œí—˜ ì„¤ê³„ì— ì–´ë–¤ ì˜ë¯¸ë¥¼ ê°€ì§€ëŠ”ì§€
2. **ì¶”ê°€ ë¶„ì„ í•„ìš”ì„±**: ì–´ë–¤ ì¶”ê°€ ë¶„ì„ì´ ì™œ í•„ìš”í•œì§€ ì˜ë£Œì  ê´€ì ì—ì„œ ì„¤ëª…
3. **ìš°ì„ ìˆœìœ„**: ê°€ì¥ ì¤‘ìš”í•œ ì¶”ê°€ ë¶„ì„ 3-5ê°œë¥¼ ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì œì‹œ
4. **ë¶„ì„ ëª©ì **: ê° ì¶”ì²œ ë¶„ì„ì´ ì„ìƒì‹œí—˜ì— ì–´ë–¤ ê°€ì¹˜ë¥¼ ì œê³µí•˜ëŠ”ì§€

ì‘ë‹µ í˜•ì‹ (JSON):
{{
    "clinical_significance": "ìŠ¤í¬ë¦¬ë‹ ê²°ê³¼ì˜ ì„ìƒì  ì˜ì˜",
    "recommended_analyses": [
        {{
            "analysis_name": "ë¶„ì„ëª…",
            "priority": 1,
            "clinical_rationale": "ì˜ë£Œì  ê·¼ê±°",
            "expected_outcome": "ì˜ˆìƒë˜ëŠ” ê²°ê³¼ì™€ í™œìš©ë°©ì•ˆ"
        }}
    ],
    "data_gaps": ["ì¶”ê°€ë¡œ í•„ìš”í•œ ë°ì´í„°ë‚˜ ë¶„ì„"],
    "next_steps": "ë‹¤ìŒ ë‹¨ê³„ ê¶Œì¥ì‚¬í•­"
}}
"""

        try:
            response = self.llm_model.generate_content(prompt)

            # JSON íŒŒì‹± ì‹œë„
            import json
            import re

            response_text = response.text.strip()
            # JSON ë¸”ë¡ ì¶”ì¶œ
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)

            if json_match:
                json_text = json_match.group(0)
                llm_analysis = json.loads(json_text)
            else:
                # JSON íŒŒì‹± ì‹¤íŒ¨ ì‹œ í…ìŠ¤íŠ¸ íŒŒì‹±
                llm_analysis = self._parse_text_response(response_text)

            print(f"ğŸ¯ LLM ë¶„ì„ ì™„ë£Œ: {len(llm_analysis.get('recommended_analyses', []))}ê°œ ë¶„ì„ ì¶”ì²œ")

            return llm_analysis

        except Exception as e:
            print(f"âš ï¸  LLM ë¶„ì„ ì‹¤íŒ¨, ê¸°ë³¸ ë¶„ì„ ì‚¬ìš©: {e}")
            return {
                "clinical_significance": "ê¸°ë³¸ ìŠ¤í¬ë¦¬ë‹ ì™„ë£Œ",
                "recommended_analyses": [
                    {
                        "analysis_name": "í™˜ì ì¸êµ¬í•™ì  íŠ¹ì„± ë¶„ì„",
                        "priority": 1,
                        "clinical_rationale": "ì—°êµ¬ ëŒ€ìƒìì˜ ê¸°ë³¸ íŠ¹ì„± íŒŒì•…",
                        "expected_outcome": "ëª¨ì§‘ ê°€ëŠ¥í•œ í™˜ìêµ° í”„ë¡œíŒŒì¼"
                    },
                    {
                        "analysis_name": "ë³‘ì› ë°©ë¬¸ íŒ¨í„´ ë¶„ì„",
                        "priority": 2,
                        "clinical_rationale": "í™˜ì ì ‘ê·¼ì„± ë° ì¶”ì ê´€ì°° ê³„íš",
                        "expected_outcome": "ìµœì  ì„ìƒì‹œí—˜ ì„¼í„° ì„ ì •"
                    }
                ],
                "data_gaps": ["ì¶”ê°€ ë¶„ì„ í•„ìš”"],
                "next_steps": "ì¶”ì²œ ë¶„ì„ ì§„í–‰"
            }

    def _parse_text_response(self, response_text: str) -> Dict:
        """LLM í…ìŠ¤íŠ¸ ì‘ë‹µ íŒŒì‹±"""
        # ê¸°ë³¸ êµ¬ì¡°ë¡œ íŒŒì‹± ì‹œë„
        return {
            "clinical_significance": "LLM ë¶„ì„ ê²°ê³¼",
            "recommended_analyses": [
                {
                    "analysis_name": "í™˜ì íŠ¹ì„± ë¶„ì„",
                    "priority": 1,
                    "clinical_rationale": "ê¸°ë³¸ ë¶„ì„",
                    "expected_outcome": "í™˜ì í”„ë¡œíŒŒì¼"
                }
            ],
            "data_gaps": [],
            "next_steps": "ë¶„ì„ ì§„í–‰"
        }

    def _llm_select_optimal_recipes(self, recommended_analyses: List[Dict], screening_summary: Dict) -> List[RecipeMatch]:
        """LLMì„ í†µí•œ ìµœì  ë ˆì‹œí”¼ ì„ íƒ"""

        print("ğŸ§  LLMì´ ìµœì  ë ˆì‹œí”¼ ì„ íƒ ì¤‘...")

        # ì‚¬ìš© ê°€ëŠ¥í•œ profile ë ˆì‹œí”¼ ì •ë³´ ìˆ˜ì§‘
        profile_recipes_info = []
        for recipe_name, recipe_info in self.agent.recipe_selector.recipe_metadata.items():
            if recipe_info['category'] == 'profile':
                profile_recipes_info.append({
                    'name': recipe_name,
                    'description': recipe_info['metadata'].get('description', ''),
                    'tags': recipe_info['metadata'].get('tags', []),
                    'parameters': recipe_info['metadata'].get('parameters', [])
                })

        # LLMì—ê²Œ ë ˆì‹œí”¼ ì„ íƒ ìš”ì²­
        prompt = f"""
ë‹¹ì‹ ì€ ì„ìƒë°ì´í„° ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. í˜„ì¬ ì„ìƒì‹œí—˜ ìŠ¤í¬ë¦¬ë‹ì´ ì™„ë£Œë˜ì—ˆê³ , **ì¶”ê°€ë¡œ í¥ë¯¸ë¡­ê³  ì˜ë¯¸ìˆëŠ” ê³ ê¸‰ ë¶„ì„**ì„ ì§„í–‰í•˜ë ¤ê³  í•©ë‹ˆë‹¤.

## ìŠ¤í¬ë¦¬ë‹ ì™„ë£Œëœ ì„ìƒì‹œí—˜ ì •ë³´:
- **ì¶”ì²œ ë¶„ì„ë“¤**: {json.dumps(recommended_analyses, ensure_ascii=False, indent=2)}
- **ìŠ¤í¬ë¦¬ë‹ ìš”ì•½**: {json.dumps(screening_summary, ensure_ascii=False, indent=2)}

## ì‚¬ìš© ê°€ëŠ¥í•œ ê³ ê¸‰ ë¶„ì„ ë ˆì‹œí”¼ë“¤:
{json.dumps(profile_recipes_info[:25], ensure_ascii=False, indent=2)}
... (ì´ {len(profile_recipes_info)}ê°œ ë ˆì‹œí”¼ ì¤‘ ì¼ë¶€)

## ğŸ¯ **í¥ë¯¸ë¡œìš´ ì¶”ê°€ ë¶„ì„ ì„ íƒ ì§€ì¹¨**:
1. **ê³„ì ˆì„±/ì‹œê°„ íŒ¨í„´**: ì§ˆë³‘ì˜ ê³„ì ˆë³„, ì›”ë³„ ë°œìƒ íŒ¨í„´ ë¶„ì„
2. **í™˜ì í´ëŸ¬ìŠ¤í„°ë§**: ë°ì´í„° ê¸°ë°˜ í™˜ìêµ° ë¶„ë¥˜ ë° íŠ¹ì„± ë¶„ì„
3. **ì˜ë£Œë¹„ íŒ¨í„´**: í™˜ìë³„, ì§ˆë³‘ë³„ ì˜ë£Œë¹„ ì§€ì¶œ íŒ¨í„´
4. **ë™ë°˜ì§ˆí™˜ ë¶„ì„**: ì£¼ìš” ë™ë°˜ì§ˆí™˜ê³¼ í•©ë³‘ì¦ íŒ¨í„´
5. **ë³µì•½ íŒ¨í„´**: ë³µì•½ìˆœì‘ë„, ì¹˜ë£Œ ì§€ì†ì„± ë¶„ì„
6. **ì§€ì—­ë³„ ì‹¬í™”**: ê³ ê¸‰ ì§€ì—­ ë°€ë„ ë° ì ‘ê·¼ì„± ë¶„ì„

## ğŸ” **ì¶”ì²œ ë ˆì‹œí”¼ ì˜ˆì‹œ** (ì„ìƒì‹œí—˜ ì£¼ì œì— ë”°ë¼ ì„ íƒ):
- `analyze_seasonal_patterns_by_disease` - ê³„ì ˆë³„ ë°œìƒ íŒ¨í„´
- `analyze_data_driven_patient_clusters` - í™˜ì í´ëŸ¬ìŠ¤í„°ë§
- `analyze_medical_expenses_by_patient` - ì˜ë£Œë¹„ íŒ¨í„´
- `get_top_comorbidities_for_cohort` - ë™ë°˜ì§ˆí™˜ ë¶„ì„
- `analyze_medication_adherence_mpr` - ë³µì•½ìˆœì‘ë„
- `analyze_advanced_regional_density` - ê³ ê¸‰ ì§€ì—­ ë¶„ì„

**ì„ìƒì‹œí—˜ ì£¼ì œì™€ í™˜ì íŠ¹ì„±ì„ ê³ ë ¤í•˜ì—¬ ê°€ì¥ í¥ë¯¸ë¡­ê³  í†µì°°ë ¥ ìˆëŠ” ì¶”ê°€ ë¶„ì„ ë ˆì‹œí”¼ 3-4ê°œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.**

ì‘ë‹µ í˜•ì‹ (JSON):
{{
    "recipe_selections": [
        {{
            "analysis_name": "ë¶„ì„ëª…",
            "selected_recipes": ["ë ˆì‹œí”¼ëª…1", "ë ˆì‹œí”¼ëª…2"],
            "selection_rationale": "ì„ íƒ ê·¼ê±°"
        }}
    ]
}}
"""

        try:
            response = self.llm_model.generate_content(prompt)

            # JSON íŒŒì‹±
            import re
            json_match = re.search(r'\{.*\}', response.text, re.DOTALL)

            selected_recipes = []
            if json_match:
                selection_data = json.loads(json_match.group(0))

                for selection in selection_data.get('recipe_selections', []):
                    for recipe_name in selection['selected_recipes']:
                        if recipe_name in self.agent.recipe_selector.recipe_metadata:
                            recipe_info = self.agent.recipe_selector.recipe_metadata[recipe_name]

                            recipe_match = RecipeMatch(
                                recipe_name=recipe_name,
                                recipe_path=str(recipe_info['path']),
                                match_score=10,  # LLM ì„ íƒ = ìµœê³ ì 
                                matched_criteria=[],
                                required_parameters={},
                                description=recipe_info['metadata'].get('description', '')
                            )
                            selected_recipes.append(recipe_match)

            print(f"âœ… LLMì´ ì„ íƒí•œ ë ˆì‹œí”¼: {len(selected_recipes)}ê°œ")
            for i, recipe in enumerate(selected_recipes, 1):
                print(f"   {i}. {recipe.recipe_name}")

            return selected_recipes

        except Exception as e:
            print(f"âš ï¸  LLM ë ˆì‹œí”¼ ì„ íƒ ì‹¤íŒ¨, ê¸°ë³¸ ë ˆì‹œí”¼ ì‚¬ìš©: {e}")

            # ë™ì  íŒŒë¼ë¯¸í„° í˜¸í™˜ì„±ì´ ë†’ì€ í¥ë¯¸ë¡œìš´ ì¶”ê°€ ë¶„ì„ ë ˆì‹œí”¼ë“¤
            default_recipes = []
            interesting_compatible_recipes = [
                'analyze_seasonal_patterns_by_disease',          # ê³„ì ˆë³„ íŒ¨í„´ ğŸŒ¸ (disease_name_keyword, dates)
                'get_top_comorbidities_for_cohort',              # ë™ë°˜ì§ˆí™˜ ë¶„ì„ ğŸ” (disease_name_keyword, dates)
                'analyze_advanced_regional_density',             # ê³ ê¸‰ ì§€ì—­ë¶„ì„ ğŸ“ (disease_name_keyword, dates, min_count)
                'analyze_hospital_visits_by_disease'             # ë³‘ì›ë°©ë¬¸íŒ¨í„´ ğŸ¥ (disease_keyword, dates)
            ]

            for recipe_name in interesting_compatible_recipes:
                if recipe_name in self.agent.recipe_selector.recipe_metadata:
                    recipe_info = self.agent.recipe_selector.recipe_metadata[recipe_name]
                    recipe_match = RecipeMatch(
                        recipe_name=recipe_name,
                        recipe_path=str(recipe_info['path']),
                        match_score=8,
                        matched_criteria=[],
                        required_parameters={},
                        description=recipe_info['metadata'].get('description', '')
                    )
                    default_recipes.append(recipe_match)

            return default_recipes

    def _execute_llm_optimized_analyses(self, selected_recipes: List[RecipeMatch],
                                      analyzed_criteria: Dict, llm_analysis: Dict) -> List[QueryResult]:
        """LLM ìµœì í™”ëœ íŒŒë¼ë¯¸í„°ë¡œ ë¶„ì„ ì‹¤í–‰"""

        if not selected_recipes:
            print("âš ï¸  ì‹¤í–‰í•  ë ˆì‹œí”¼ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return []

        print(f"ğŸš€ LLM ìµœì í™” ë¶„ì„ ì‹¤í–‰: {len(selected_recipes)}ê°œ ë ˆì‹œí”¼")

        results = []

        for recipe_match in selected_recipes:
            try:
                print(f"ğŸ“Š ì‹¤í–‰ ì¤‘: {recipe_match.recipe_name}")

                # LLM ê¸°ë°˜ íŒŒë¼ë¯¸í„° ìµœì í™”
                optimized_parameters = self._llm_optimize_parameters(
                    recipe_match, analyzed_criteria, llm_analysis
                )

                # ê°œë³„ ë ˆì‹œí”¼ ì‹¤í–‰ì„ ìœ„í•´ ì‹œí€€ìŠ¤ë¡œ ë³€í™˜
                recipe_sequence = [recipe_match]
                override_params = {recipe_match.recipe_name: optimized_parameters}
                results_list = self.agent.query_executor.execute_recipe_sequence(
                    recipe_sequence, self.agent.parameter_extractor,
                    analyzed_criteria, dry_run=True,
                    override_parameters=override_params
                )
                if results_list and len(results_list) > 0:
                    result = results_list[0]
                    results.append(result)
                    print(f"   âœ… ì™„ë£Œ: {recipe_match.recipe_name}")
                else:
                    # ì‹¤í–‰ ì‹¤íŒ¨ì‹œ ì˜¤ë¥˜ ê²°ê³¼ ìƒì„±
                    error_result = QueryResult(
                        recipe_name=recipe_match.recipe_name,
                        success=False,
                        error_message="ë ˆì‹œí”¼ ì‹¤í–‰ ì‹¤íŒ¨ - ê²°ê³¼ ì—†ìŒ",
                        execution_time=0.0
                    )
                    results.append(error_result)
                    print(f"   âŒ ì‹¤íŒ¨: {recipe_match.recipe_name} - ê²°ê³¼ ì—†ìŒ")

            except Exception as e:
                print(f"   âŒ ì‹¤íŒ¨: {recipe_match.recipe_name} - {e}")
                error_result = QueryResult(
                    recipe_name=recipe_match.recipe_name,
                    success=False,
                    error_message=str(e),
                    execution_time=0.0
                )
                results.append(error_result)

        return results

    def _llm_optimize_parameters(self, recipe_match: RecipeMatch,
                               analyzed_criteria: Dict, llm_analysis: Dict) -> Dict:
        """LLMì„ í†µí•œ íŒŒë¼ë¯¸í„° ìµœì í™” (ì•ˆì „ì„± ê°œì„ )"""

        if not self._is_llm_available():
            print(f"   âš ï¸  LLM ì‚¬ìš© ë¶ˆê°€, ê¸°ë³¸ íŒŒë¼ë¯¸í„° ì‚¬ìš©")
            return self.agent.parameter_extractor.extract_parameters_for_recipe(
                recipe_match, analyzed_criteria
            )

        # ê¸°ë³¸ íŒŒë¼ë¯¸í„° ì¶”ì¶œ
        base_parameters = self.agent.parameter_extractor.extract_parameters_for_recipe(
            recipe_match, analyzed_criteria
        )

        # LLMì—ê²Œ íŒŒë¼ë¯¸í„° ìµœì í™” ìš”ì²­
        recipe_info = self.agent.recipe_selector.recipe_metadata[recipe_match.recipe_name]
        parameter_specs = recipe_info['metadata'].get('parameters', [])

        prompt = f"""
ë‹¤ìŒ ë ˆì‹œí”¼ì˜ íŒŒë¼ë¯¸í„°ë¥¼ ì„ìƒì‹œí—˜ ë§¥ë½ì— ë§ê²Œ ìµœì í™”í•´ì£¼ì„¸ìš”.

## ë ˆì‹œí”¼: {recipe_match.recipe_name}
## ì„¤ëª…: {recipe_match.description}

## íŒŒë¼ë¯¸í„° ìŠ¤í™:
{json.dumps(parameter_specs, ensure_ascii=False, indent=2)}

## ê¸°ë³¸ íŒŒë¼ë¯¸í„° ê°’:
{json.dumps(base_parameters, ensure_ascii=False, indent=2)}

## ì„ìƒì‹œí—˜ ë§¥ë½:
{json.dumps(llm_analysis, ensure_ascii=False, indent=2)}

## ìµœì í™” ìš”ì²­:
- ì„ìƒì‹œí—˜ ëª©ì ì— ë§ëŠ” ìµœì  íŒŒë¼ë¯¸í„° ê°’ ì œì•ˆ
- top_n, limit ë“±ì€ ì„ìƒì ìœ¼ë¡œ ì˜ë¯¸ìˆëŠ” ìˆ˜ì¤€ìœ¼ë¡œ ì¡°ì •
- ê¸°ê°„, ë²”ìœ„ ë“±ì€ ì‹¤ì œ ì„ìƒì‹œí—˜ ì¼ì •ì„ ê³ ë ¤

ìµœì í™”ëœ íŒŒë¼ë¯¸í„°ë¥¼ JSON í˜•íƒœë¡œ ì œê³µí•´ì£¼ì„¸ìš”:
{{"parameter_name": "optimized_value"}}
"""

        try:
            response = self.llm_model.generate_content(prompt)

            # JSON íŒŒì‹± ì‹œë„
            import re
            json_match = re.search(r'\{.*\}', response.text, re.DOTALL)

            if json_match:
                optimized_params = json.loads(json_match.group(0))
                # ê¸°ë³¸ íŒŒë¼ë¯¸í„°ì™€ ë³‘í•©
                final_parameters = {**base_parameters, **optimized_params}
                print(f"   ğŸ¯ LLM íŒŒë¼ë¯¸í„° ìµœì í™” ì™„ë£Œ")
                return final_parameters
            else:
                return base_parameters

        except Exception as e:
            print(f"   âš ï¸  íŒŒë¼ë¯¸í„° ìµœì í™” ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©: {e}")
            return base_parameters

    def _fallback_analysis(self, screening_results: List[QueryResult], analyzed_criteria: Dict, trial_name: str) -> Dict:
        """LLM ì—†ì´ ê¸°ë³¸ ë¶„ì„ ìˆ˜í–‰"""
        print("ğŸ“Š ê¸°ë³¸ ë¶„ì„ ëª¨ë“œë¡œ ì‹¤í–‰...")

        # ê¸°ë³¸ì ì¸ í†µê³„ ë¶„ì„ë§Œ ìˆ˜í–‰
        screening_summary = self._extract_screening_summary(screening_results)

        # ê¸°ë³¸ ê¶Œì¥ì‚¬í•­ ìƒì„±
        basic_recommendations = []
        if any("í™˜ì" in str(result.generated_sql) for result in screening_results if result.success):
            basic_recommendations.append("í™˜ì í”„ë¡œíŒŒì¼ë§ ë¶„ì„")
        if any("ë³‘ì›" in str(result.generated_sql) for result in screening_results if result.success):
            basic_recommendations.append("ë³‘ì› ë¶„í¬ ë¶„ì„")

        return {
            "overall_assessment": "ê¸°ë³¸ ë¶„ì„ ëª¨ë“œ: LLM ê¸°ë°˜ ìƒì„¸ ë¶„ì„ì€ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
            "feasibility_score": "N/A",
            "key_insights": ["ìŠ¤í¬ë¦¬ë‹ ê²°ê³¼ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ ê¸°ë³¸ í†µê³„ ë¶„ì„"],
            "recommended_analyses": basic_recommendations[:3],  # ìµœëŒ€ 3ê°œ
            "data_gaps": ["LLM ë¶„ì„ì„ ìœ„í•œ API í‚¤ ì„¤ì • í•„ìš”"],
            "next_steps": "API í‚¤ë¥¼ ì„¤ì •í•˜ì—¬ LLM ê¸°ë°˜ ìƒì„¸ ë¶„ì„ì„ í™œì„±í™”í•˜ì„¸ìš”"
        }


import streamlit as st
import os
import re
import io
import yaml
import pandas as pd
import json
import google.generativeai as genai
from datetime import date, timedelta
from jinja2 import Template
import plotly.express as px
import plotly.graph_objects as go


# --- 1. Helper Functions ---

@st.cache_data
def load_recipes():
    """Load all recipe YAML files from the recipes directory."""
    recipe_dir = "recipes"
    recipes = []
    if not os.path.exists(recipe_dir):
        st.error(f"Recipe directory '{recipe_dir}' not found.")
        return recipes
        
    for subdir, _, files in os.walk(recipe_dir):
        for file in files:
            if file.endswith(".yaml"):
                file_path = os.path.join(subdir, file)
                with open(file_path, "r", encoding="utf-8") as f:
                    try:
                        recipe = yaml.safe_load(f)
                        if recipe and 'name' in recipe:
                            recipe['sql_file_path'] = file_path.replace(".yaml", ".sql")
                            recipes.append(recipe)
                    except yaml.YAMLError as e:
                        st.error(f"Error loading YAML file {file_path}: {e}")
    return recipes

@st.cache_data
def load_data_dictionary():
    """Load the data dictionary CSV file."""
    dict_path = "notion_columns_improved.csv"
    if os.path.exists(dict_path):
        return pd.read_csv(dict_path)
    return None

def get_sql_from_recipe(recipe):
    """Get the SQL query content from a recipe's SQL file."""
    try:
        with open(recipe['sql_file_path'], "r", encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        return f"Error: SQL file not found at {recipe['sql_file_path']}"
    except Exception as e:
        return f"An error occurred: {e}"

def fill_sql_parameters(sql_template, params):
    """Renders the SQL template using Jinja2 to handle complex logic and special placeholders."""
    render_params = (params or {}).copy()

    for key, value in render_params.items():
        if isinstance(value, str):
            if value == '[DEFAULT_3_YEARS_AGO]':
                three_years_ago = date.today() - timedelta(days=3*365)
                render_params[key] = three_years_ago.strftime('%Y-%m-%d')
            elif value == '[CURRENT_DATE]':
                render_params[key] = date.today().strftime('%Y-%m-%d')
            elif value == '[NOT_FOUND]':
                render_params[key] = None
            else:
                match = re.match(r'\[DEFAULT_(\w+)\]', value)
                if match:
                    render_params[key] = match.group(1)

    try:
        template = Template(sql_template)
        return template.render(render_params)
    except Exception as e:
        return f"Error rendering Jinja2 template: {e}"

def get_report_structure_with_llm(user_query, all_recipes, mandatory_recipes=None):
    """Generate a report structure and extract parameters using the LLM."""
    try:
        with open("config.yaml", "r") as f:
            config = yaml.safe_load(f)
            api_key = config.get("api_keys", {}).get("gemini_api_key")

        if not api_key or api_key == "YOUR_GEMINI_API_KEY_HERE":
            st.error("Gemini API key is not configured. Please set it in `config.yaml`.")
            return None

        genai.configure(api_key=api_key)
        model = genai.GenerativeModel('gemini-2.5-flash')

        recipe_details = []
        for r in all_recipes:
            param_info = ", ".join([p['name'] for p in r.get('parameters', [])])
            recipe_details.append(
                f"- Recipe Name: {r.get('name')}\n  Description: {r.get('description')}\n  Category: {r.get('category')}\n  Parameters: [{param_info}]"
            )
        recipe_info_for_prompt = "\n".join(recipe_details)

        mandatory_recipes_prompt_part = ""
        if mandatory_recipes:
            mandatory_recipes_list = "\n".join([f"- {r}" for r in mandatory_recipes])
            mandatory_recipes_prompt_part = f"""
        IMPORTANT: The user has explicitly requested that the following recipes MUST be included in the report. Please build your narrative and report structure around them, while also selecting other relevant recipes to complete the story.
        ---
        MANDATORY RECIPES:
        {mandatory_recipes_list}
        ---
        """

        prompt = f"""You are a seasoned consultant for pharmaceutical companies, specializing in clinical data analysis and market strategy. Your task is to create a comprehensive report outline based on a user's request, tailored for a pharmaceutical company's drug development pipeline (e.g., market analysis, patient segmentation, clinical trial feasibility).

        {mandatory_recipes_prompt_part}

        IMPORTANT CONTEXT: The data must be filtered by the disease NAME (e.g., 'ê³ í˜ˆì••') in the 'res_disease_name' column, NOT by disease code. The queries will be run on a Databricks environment.

        Based on the user's query: '{user_query}'

        And the following available analysis recipes:
        ---
        {recipe_info_for_prompt}
        ---

        Perform the following tasks:
        1.  **Analyze User Intent:** Determine if the user wants a "Feasibility Report" for clinical trial recruitment or a "Market Landscape Report" for a drug pipeline.
        2.  **Create a Narrative:** Based on the intent, devise a logical narrative for the strategic report.
        3.  **Select Recipes:** Choose a sequence of 3 to 5 recipes that best fit this narrative. If mandatory recipes are provided, you must use them.
        4.  **Extract Parameters:** For each recipe, extract parameters from the user's query. Use placeholders like '[NOT_FOUND]', '[DEFAULT_3_YEARS_AGO]', '[CURRENT_DATE]', or '[DEFAULT_50]' if a value isn't present.
        5.  **Generate Report Components:** Write a professional report title, a concise executive summary explaining the report's purpose, a table of contents, and a 'rationale' for each page explaining why that analysis is important for the strategic goal.

        Your output MUST be a single JSON object. Here are two examples of the expected output structure based on the user's intent.

        ---
        **EXAMPLE 1: Feasibility Report**
        - User Query: "ì²œì‹ì„ ë™ë°˜í•œ ë‹¤ë…„ì„± ì•Œë ˆë¥´ê¸° ë¹„ì—¼ í™˜ì ëŒ€ìƒ DW1807 3ìƒ ì„ìƒì‹œí—˜ í™˜ì ëª¨ì§‘ íƒ€ë‹¹ì„± ë¶„ì„"
        - Your JSON Output:
        ```json
        {{
            "report_title": "DW1807 ì„ìƒì‹œí—˜ í™˜ì ëª¨ì§‘ íƒ€ë‹¹ì„± ë¶„ì„",
            "executive_summary": "ë³¸ ë³´ê³ ì„œëŠ” 'ì²œì‹ì„ ë™ë°˜í•œ ë‹¤ë…„ì„± ì•Œë ˆë¥´ê¸° ë¹„ì—¼' í™˜ì ëŒ€ìƒ DW1807 3ìƒ ì„ìƒì‹œí—˜ì˜ í™˜ì ëª¨ì§‘ íƒ€ë‹¹ì„±ì„ ë¶„ì„í•©ë‹ˆë‹¤. ëª©í‘œ ëª¨ì§‘ ì¸ì› 200ëª…ì— ëŒ€í•´, í˜„ì¬ ë³´ìœ í•œ RWD ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì˜ˆìƒ ëª¨ì§‘ ì„±ê³µë¥  ë° ì†Œìš” ê¸°ê°„ì„ ì˜ˆì¸¡í•˜ì—¬ ì„ìƒì‹œí—˜ì˜ ì„±ê³µ ê°€ëŠ¥ì„±ì„ í‰ê°€í•˜ëŠ” ê²ƒì„ ëª©ì ìœ¼ë¡œ í•©ë‹ˆë‹¤.",
            "table_of_contents": [
                "1. ëª¨ì§‘ ì„±ê³µë¥  ë° ì†Œìš” ê¸°ê°„ ì˜ˆì¸¡",
                "2. í™˜ìêµ° ìƒì„¸ í”„ë¡œíŒŒì¼ ë¶„ì„",
                "3. ì£¼ìš” ë™ë°˜ ì§ˆí™˜ ë¶„ì„",
                "4. ê²½ìŸ ë° ê¸°ì¡´ ì²˜ë°© ì•½ë¬¼ í˜„í™©"
            ],
            "pages": [
                {{
                    "title": "1. ëª¨ì§‘ ì„±ê³µë¥  ë° ì†Œìš” ê¸°ê°„ ì˜ˆì¸¡",
                    "rationale": "ì „ì²´ í™˜ì í’€ì—ì„œë¶€í„° ì£¼ìš” í¬í•¨/ì œì™¸ ê¸°ì¤€ì„ ì ìš©í•˜ì—¬ ìµœì¢… ëª¨ì§‘ ê°€ëŠ¥í•œ í™˜ì ìˆ˜ë¥¼ ì˜ˆì¸¡í•˜ê³ , ì´ë¥¼ í†µí•´ ëª©í‘œ ì¸ì› ë‹¬ì„± ê°€ëŠ¥ì„±ê³¼ ì˜ˆìƒ ì†Œìš” ê¸°ê°„ì„ ì‚°ì¶œí•©ë‹ˆë‹¤.",
                    "recipe_name": "analyze_recruitment_feasibility",
                    "parameters": {{"disease_name_keyword": "ì•Œë ˆë¥´ê¸° ë¹„ì—¼", "min_age": 19, "max_age": 75, "min_visits": 1, "target_enrollment": 200}}
                }},
                {{
                    "title": "2. í™˜ìêµ° ìƒì„¸ í”„ë¡œíŒŒì¼ ë¶„ì„",
                    "rationale": "ëª¨ì§‘ ëŒ€ìƒ í™˜ìêµ°ì˜ ì¸êµ¬í†µê³„í•™ì  íŠ¹ì„±(ì„±ë³„, ì—°ë ¹) ë° ì§€ì—­ì  ë¶„í¬ë¥¼ íŒŒì•…í•˜ì—¬, ë¦¬í¬ë£¨íŒ… ì „ëµ ìˆ˜ë¦½ ì‹œ íƒ€ê²Ÿ ëŒ€ìƒì„ ëª…í™•íˆ í•©ë‹ˆë‹¤.",
                    "recipe_name": "get_demographic_distribution_by_disease",
                    "parameters": {{"disease_name_keyword": "ì•Œë ˆë¥´ê¸° ë¹„ì—¼", "start_date": "[DEFAULT_3_YEARS_AGO]", "end_date": "[CURRENT_DATE]"}}
                }},
                {{
                    "title": "3. ì£¼ìš” ë™ë°˜ ì§ˆí™˜ ë¶„ì„",
                    "rationale": "ëŒ€ìƒ í™˜ìêµ°ì´ ë³´ìœ í•œ ì£¼ìš” ë™ë°˜ ì§ˆí™˜ì„ íŒŒì•…í•˜ì—¬, ì„ìƒì‹œí—˜ ì§„í–‰ ì¤‘ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì ì¬ì  ë¦¬ìŠ¤í¬ë¥¼ ê´€ë¦¬í•˜ê³ , ë³µí•©ì ì¸ í™˜ì íŠ¹ì„±ì„ ì´í•´í•©ë‹ˆë‹¤.",
                    "recipe_name": "get_top_comorbidities_for_cohort",
                    "parameters": {{"disease_name_keyword": "ì•Œë ˆë¥´ê¸° ë¹„ì—¼", "start_date": "[DEFAULT_3_YEARS_AGO]", "end_date": "[CURRENT_DATE]", "top_n": 10}}
                }},
                {{
                    "title": "4. ê²½ìŸ ë° ê¸°ì¡´ ì²˜ë°© ì•½ë¬¼ í˜„í™©",
                    "rationale": "í˜„ì¬ ì‹œì¥ì—ì„œ ì²˜ë°©ë˜ê³  ìˆëŠ” ì£¼ìš” ì•½ë¬¼ë“¤ì„ íŒŒì•…í•˜ì—¬, ëŒ€ìƒ í™˜ìêµ°ì˜ ê¸°ì¡´ ì¹˜ë£Œ íŒ¨í„´ì„ ì´í•´í•˜ê³  ì„ìƒì‹œí—˜ ì„¤ê³„ ì‹œ ëŒ€ì¡°êµ° ì„¤ì • ë° ì‹œì¥ ì§„ì… ì „ëµì— í™œìš©í•©ë‹ˆë‹¤.",
                    "recipe_name": "get_top_prescribed_ingredients_by_disease",
                    "parameters": {{"disease_name_keyword": "ì•Œë ˆë¥´ê¸° ë¹„ì—¼", "start_date": "[DEFAULT_3_YEARS_AGO]", "end_date": "[CURRENT_DATE]", "top_n": 10}}
                }}
            ]
        }}
        ```
        ---
        **EXAMPLE 2: Market Landscape Report**
        - User Query: "ì›í˜•íƒˆëª¨ì¦ ì‹ ì•½ ì‹œì¥ì„± ë¶„ì„"
        - Your JSON Output:
        ```json
        {{
            "report_title": "ì›í˜•íƒˆëª¨ì¦ ì‹œì¥ ë¶„ì„ ë° í™˜ì í”„ë¡œíŒŒì¼ë§",
            "executive_summary": "ë³¸ ë³´ê³ ì„œëŠ” ì‹ ê·œ ì›í˜•íƒˆëª¨ì¦ ì¹˜ë£Œì œ ê°œë°œì„ ìœ„í•œ ì‹œì¥ì„± ë¶„ì„ì„ ëª©ì ìœ¼ë¡œ í•©ë‹ˆë‹¤. RWDë¥¼ ê¸°ë°˜ìœ¼ë¡œ êµ­ë‚´ ì›í˜•íƒˆëª¨ì¦ ì‹œì¥ì˜ ê·œëª¨ë¥¼ ì¶”ì •í•˜ê³ , í™˜ì íŠ¹ì„± ë° ì£¼ìš” ì˜ë£Œ ì´ìš© íŒ¨í„´ì„ ë¶„ì„í•˜ì—¬, ì„±ê³µì ì¸ ì‹ ì•½ ê°œë°œ ë° ì‹œì¥ ì§„ì… ì „ëµ ìˆ˜ë¦½ì„ ìœ„í•œ í•µì‹¬ ì¸ì‚¬ì´íŠ¸ë¥¼ ì œê³µí•©ë‹ˆë‹¤.",
            "table_of_contents": [
                "1. ì „ì²´ ì‹œì¥ ê·œëª¨ ë¶„ì„",
                "2. í™˜ì ì¸êµ¬í†µê³„í•™ì  íŠ¹ì„±",
                "3. ì£¼ìš” ì˜ë£Œ ì´ìš© íŒ¨í„´ (ë³‘ì› ë“±ê¸‰ë³„)",
                "4. ì£¼ìš” ì²˜ë°© ì•½ë¬¼ ë¶„ì„"
            ],
            "pages": [
                {{
                    "title": "1. ì „ì²´ ì‹œì¥ ê·œëª¨ ë¶„ì„",
                    "rationale": "êµ­ë‚´ ì›í˜•íƒˆëª¨ì¦ í™˜ìì˜ ì „ì²´ ìˆ˜ë¥¼ íŒŒì•…í•˜ì—¬ ì‹œì¥ì˜ ë§¤ë ¥ë„ë¥¼ í‰ê°€í•˜ê³ , ì ì¬ì  ì‹œì¥ ê·œëª¨ë¥¼ ì˜ˆì¸¡í•©ë‹ˆë‹¤.",
                    "recipe_name": "get_patient_count_by_disease_keyword",
                    "parameters": {{"disease_keyword": "ì›í˜•íƒˆëª¨ì¦"}}
                }},
                {{
                    "title": "2. í™˜ì ì¸êµ¬í†µê³„í•™ì  íŠ¹ì„±",
                    "rationale": "ì£¼ìš” í™˜ìêµ°ì˜ ì„±ë³„ ë° ì—°ë ¹ëŒ€ ë¶„í¬ë¥¼ ë¶„ì„í•˜ì—¬, ë§ˆì¼€íŒ… ë° ê°œë°œ ì „ëµ ìˆ˜ë¦½ ì‹œ í•µì‹¬ íƒ€ê²Ÿì´ ë  ì¸êµ¬í†µê³„í•™ì  ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì‹ë³„í•©ë‹ˆë‹¤.",
                    "recipe_name": "get_demographic_distribution_by_disease",
                    "parameters": {{"disease_name_keyword": "ì›í˜•íƒˆëª¨ì¦", "start_date": "[DEFAULT_3_YEARS_AGO]", "end_date": "[CURRENT_DATE]"}}
                }},
                {{
                    "title": "3. ì£¼ìš” ì˜ë£Œ ì´ìš© íŒ¨í„´ (ë³‘ì› ë“±ê¸‰ë³„)",
                    "rationale": "í™˜ìë“¤ì´ ì£¼ë¡œ ì´ìš©í•˜ëŠ” ë³‘ì› ë“±ê¸‰(1, 2, 3ì°¨)ì„ ë¶„ì„í•˜ì—¬, ì œí’ˆ ì¶œì‹œ í›„ ì˜ì—… ë° ë§ˆì¼€íŒ… ì±„ë„ ì „ëµì„ ìˆ˜ë¦½í•˜ëŠ” ë° í™œìš©í•©ë‹ˆë‹¤.",
                    "recipe_name": "analyze_visits_by_hospital_tier",
                    "parameters": {{"disease_keyword": "ì›í˜•íƒˆëª¨ì¦"}}
                }},
                {{
                    "title": "4. ì£¼ìš” ì²˜ë°© ì•½ë¬¼ ë¶„ì„",
                    "rationale": "í˜„ì¬ ì‹œì¥ì˜ í‘œì¤€ ì¹˜ë£Œ(Standard of Care)ì™€ ì£¼ìš” ê²½ìŸ ì•½ë¬¼ì„ íŒŒì•…í•˜ì—¬, ê°œë°œ ì¤‘ì¸ ì‹ ì•½ì˜ ì‹œì¥ ë‚´ í¬ì§€ì…”ë‹ ë° ì°¨ë³„í™” ì „ëµì„ ìˆ˜ë¦½í•©ë‹ˆë‹¤.",
                    "recipe_name": "get_top_prescribed_ingredients_by_disease",
                    "parameters": {{"disease_name_keyword": "ì›í˜•íƒˆëª¨ì¦", "start_date": "[DEFAULT_3_YEARS_AGO]", "end_date": "[CURRENT_DATE]", "top_n": 10}}
                }}
            ]
        }}
        ```
        ---

        Ensure the recipe names and parameter names in your output *exactly* match the provided list. Now, generate the JSON for the user's query: '{user_query}'.
        """

        response = model.generate_content(prompt)
        cleaned_response_text = response.text.strip().replace("```json", "").replace("```", "")
        return json.loads(cleaned_response_text)

    except Exception as e:
        st.error(f"An error occurred while communicating with the LLM: {e}")
        return None

def robust_csv_parser(data_input):
    """Parses CSV-like data from a string or uploaded file using pandas' auto-detection."""
    if hasattr(data_input, 'getvalue'):
        text_data = data_input.getvalue().decode('utf-8')
    else:
        text_data = str(data_input)
    
    csv_file = io.StringIO(text_data)
    # Use sep=None and engine='python' to auto-detect separators
    df = pd.read_csv(csv_file, sep=None, engine='python')
    return df

# --- Main App Logic ---

st.set_page_config(page_title="Clinical Report Query Generator", layout="wide")
st.title("ğŸ“‘ Clinical Report Query Generator")
st.caption("AI-powered SQL generator for clinical data analysis...")

if 'report_structure' not in st.session_state:
    st.session_state.report_structure = None

with st.spinner("Loading recipes and data dictionary..."):
    all_recipes = load_recipes()
    recipe_dict = {recipe['name']: recipe for recipe in all_recipes if recipe}
    data_dictionary = load_data_dictionary()

if not all_recipes:
    st.stop()

# --- Sidebar ---
st.sidebar.header("User Input")
user_query = st.sidebar.text_area(
    "ë¶„ì„ ë¦¬í¬íŠ¸ì˜ ì£¼ì œë‚˜ ì›í•˜ëŠ” ë¶„ì„ íë¦„ì„ ììœ ë¡­ê²Œ ì…ë ¥í•˜ì„¸ìš”. (ì˜ˆ: \"20ëŒ€ ì—¬ì„± ë¹„ë§Œ í™˜ì í”„ë¡œíŒŒì¼ë§\" ë˜ëŠ” \"ì‹œì¥ ê·œëª¨ë¥¼ ë¨¼ì € ë³´ê³ , ë‹¤ìŒìœ¼ë¡œ ì£¼ìš” ì²˜ë°© ì•½ë¬¼ì„ ë¶„ì„í•˜ëŠ” ë³´ê³ ì„œ\")",
    height=100,
    key="user_query_input"
)

# --- New UI for mandatory recipes ---
st.sidebar.subheader("í•„ìˆ˜ í¬í•¨ ë ˆì‹œí”¼ ì„ íƒ (ì˜µì…˜)")
# Group full recipe objects by category
categorized_recipes = {}
for r in all_recipes:
    cat = r.get('category', 'Uncategorized')
    if cat not in categorized_recipes:
        categorized_recipes[cat] = []
    categorized_recipes[cat].append(r)

selected_recipes = []
# Sort categories for consistent order
for category in sorted(categorized_recipes.keys()):
    with st.sidebar.expander(f"ì¹´í…Œê³ ë¦¬: {category}", expanded=False):
        # Sort recipes within the category by name
        for recipe in sorted(categorized_recipes[category], key=lambda x: x['name']):
            recipe_name = recipe['name']
            recipe_desc = recipe.get('description', 'No description available.')
            # Use checkbox with description as label
            if st.checkbox(f"{recipe_name}: {recipe_desc}", key=f"checkbox_{recipe_name}"):
                selected_recipes.append(recipe_name)
# --- End of New UI ---

def clear_report_state():
    st.session_state.report_structure = None
    for key in list(st.session_state.keys()):
        if key.startswith('dataframe_') or key.startswith('csv_input_') or key.startswith('uploader_'):
            del st.session_state[key]

if st.sidebar.button("Generate Report", type="primary"):
    clear_report_state()
    if user_query:
        with st.spinner("AI is generating the report..."):
            # Pass selected_recipes to the LLM function
            st.session_state.report_structure = get_report_structure_with_llm(user_query, all_recipes, selected_recipes)
    else:
        st.warning("Please enter a topic for the report.")

if st.sidebar.button("Clear Report"):
    clear_report_state()

st.sidebar.divider()
if st.sidebar.toggle("Show Data Dictionary", False):
    st.subheader("Data Dictionary")
    if data_dictionary is not None:
        st.dataframe(data_dictionary)
    else:
        st.warning("Data dictionary file (`notion_columns_improved.csv`) not found.")

# --- Main Content ---
# Create main tabs
tab_names = ["ğŸ  í™ˆ", "ğŸ”¬ íŒŒì´í”„ë¼ì¸ ë¶„ì„", "ğŸ¤– AI ì¿¼ë¦¬ ìƒì„±", "ğŸ“Š ë¦¬í¬íŠ¸ ë³´ê¸°"]
# Conditionally add clinical trial tab (will be deprecated)
# if CLINICAL_TRIAL_AVAILABLE:
#     tab_names.append("ğŸ¥ Clinical Trial Screening")

main_tabs = st.tabs(tab_names)

# Tab 1: í™ˆ (Home - existing query builder functionality)
with main_tabs[0]:
    if st.session_state.report_structure:
        report_structure = st.session_state.report_structure
        if "report_title" in report_structure and "pages" in report_structure:
            st.header(report_structure["report_title"])

            # Display Executive Summary and ToC
            if "executive_summary" in report_structure:
                st.subheader("Executive Summary")
                st.markdown(report_structure["executive_summary"])

            if "table_of_contents" in report_structure:
                st.subheader("Table of Contents")
                for item in report_structure["table_of_contents"]:
                    st.markdown(f"- {item}")

            st.divider()

            tab_titles = [page.get("title", f"Page {i+1}") for i, page in enumerate(report_structure["pages"])]
            tabs = st.tabs(tab_titles)

            for i, page in enumerate(report_structure["pages"]):
                with tabs[i]:
                    recipe_name = page.get("recipe_name")
                    recipe = recipe_dict.get(recipe_name)
                    llm_params = page.get("parameters", {})

                    if not recipe:
                        st.error(f"LLM recommended recipe '{recipe_name}', but it was not found.")
                        continue

                    # Display the rationale
                    if "rationale" in page:
                        st.info(f"**Rationale:** {page['rationale']}")

                    st.subheader(f"Recipe: `{recipe_name}`")
                    st.markdown(f"**Description:** {recipe.get('description', 'N/A')}")
                    st.json(llm_params)

                    st.subheader("Final SQL Query")
                    sql_template = get_sql_from_recipe(recipe)
                    final_sql = fill_sql_parameters(sql_template, llm_params)
                    st.code(final_sql, language="sql")

                    st.divider()
                    st.subheader("ğŸ“Š Generate Visualization")
                    df_key = f"dataframe_{i}"

                    viz_tab1, viz_tab2 = st.tabs(["Paste Text", "Upload File"])

                    with viz_tab1:
                        csv_input_key = f"csv_input_{i}"
                        st.text_area("Paste CSV data...", height=150, key=csv_input_key)
                        if st.button("Generate from Text", key=f"text_button_{i}"):
                            csv_text = st.session_state.get(csv_input_key, "")
                            if csv_text:
                                try:
                                    df = robust_csv_parser(csv_text)
                                    st.session_state[df_key] = df
                                except Exception as e:
                                    st.error(f"Failed to parse CSV from text: {e}")
                                    if df_key in st.session_state: del st.session_state[df_key]
                            else:
                                st.warning("Please paste CSV data first.")

                    with viz_tab2:
                        upload_key = f"uploader_{i}"
                        uploaded_file = st.file_uploader("Upload CSV file...", type=["csv", "txt"], key=upload_key)
                        if uploaded_file is not None:
                            try:
                                df = robust_csv_parser(uploaded_file)
                                st.session_state[df_key] = df
                            except Exception as e:
                                st.error(f"Failed to parse CSV from file: {e}")
                                if df_key in st.session_state: del st.session_state[df_key]

                    if df_key in st.session_state:
                        df = st.session_state[df_key]
                        viz_info = recipe.get("visualization")

                        st.write("**Chart:**")
                        if viz_info:
                            chart_type = viz_info.get("chart_type")
                            chart_title = viz_info.get("title", "")

                            try:
                                if chart_type == "bar_chart":
                                    x_col = viz_info.get("x_column")
                                    y_col = viz_info.get("y_column")

                                    # Create Plotly bar chart
                                    fig = px.bar(
                                        df,
                                        x=x_col,
                                        y=y_col,
                                        title=chart_title,
                                        labels={x_col: x_col, y_col: y_col},
                                        color_discrete_sequence=['#1f77b4']
                                    )
                                    fig.update_layout(
                                        xaxis_title=x_col,
                                        yaxis_title=y_col,
                                        hovermode='x unified'
                                    )
                                    st.plotly_chart(fig, use_container_width=True)

                                elif chart_type == "line_chart":
                                    x_col = viz_info.get("x_column")
                                    y_col = viz_info.get("y_column")

                                    # Create Plotly line chart
                                    fig = px.line(
                                        df,
                                        x=x_col,
                                        y=y_col,
                                        title=chart_title,
                                        labels={x_col: x_col, y_col: y_col},
                                        markers=True
                                    )
                                    fig.update_layout(
                                        xaxis_title=x_col,
                                        yaxis_title=y_col,
                                        hovermode='x unified'
                                    )
                                    st.plotly_chart(fig, use_container_width=True)

                                elif chart_type == "metric":
                                    # For single-row dataframes, display each column as a metric
                                    if not df.empty:
                                        cols = st.columns(len(df.columns))
                                        for j, col_name in enumerate(df.columns):
                                            cols[j].metric(label=col_name, value=df.iloc[0][col_name])
                                    else:
                                        st.warning("Data is empty, cannot display metrics.")

                                else: # Default to table
                                    st.write("**Parsed Data Table:**")
                                    st.dataframe(df)

                            except Exception as e:
                                st.error(f"Failed to generate chart: {e}")
                                st.write("Displaying raw data instead:")
                                st.dataframe(df)
                        else:
                            st.write("No visualization info in recipe. Displaying raw data table.")
                            st.dataframe(df)

        else:
            st.error("Failed to generate a valid report structure from the LLM.")
    else:
        st.info("Enter a topic in the sidebar and click 'Generate Report' to begin.")

# Tab 2: íŒŒì´í”„ë¼ì¸ ë¶„ì„ (Disease-Centric Pipeline Analysis - Phase 6)
with main_tabs[1]:
    st.header("ğŸ”¬ ì§ˆí™˜ ì¤‘ì‹¬ íŒŒì´í”„ë¼ì¸ ë¶„ì„")
    st.markdown("**ì§ˆí™˜ëª…ë§Œ ì…ë ¥í•˜ë©´ ìë™ìœ¼ë¡œ í•µì‹¬ ë¶„ì„ê³¼ ë§ì¶¤ ì¶”ì²œ ë¶„ì„ì„ ì œê³µí•©ë‹ˆë‹¤.**")

    # Import disease pipeline
    try:
        from disease_pipeline import DiseaseAnalysisPipeline

        # Initialize pipeline
        if 'disease_pipeline' not in st.session_state:
            try:
                st.session_state.disease_pipeline = DiseaseAnalysisPipeline(recipe_dir="recipes")
            except Exception as e:
                st.error(f"íŒŒì´í”„ë¼ì¸ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
                st.session_state.disease_pipeline = None

        if st.session_state.disease_pipeline:
            pipeline = st.session_state.disease_pipeline

            # Step 1: Disease name input
            st.subheader("1ï¸âƒ£ ì§ˆí™˜ëª… ì…ë ¥")
            disease_name = st.text_input(
                "ë¶„ì„í•˜ê³  ì‹¶ì€ ì§ˆí™˜ëª…ì„ ì…ë ¥í•˜ì„¸ìš”",
                value="ë‹¹ë‡¨ë³‘",
                help="ì˜ˆ: ë‹¹ë‡¨ë³‘, ê³ í˜ˆì••, ì²œì‹, ê³¨ë‹¤ê³µì¦ ë“±",
                key="pipeline_disease_input"
            )

            # Step 2: Run core recipes and get recommendations
            if st.button("ğŸ” ë¶„ì„ ì‹œì‘", type="primary", key="start_pipeline_analysis"):
                if disease_name:
                    with st.spinner("ğŸ”„ í•µì‹¬ ë¶„ì„ ì‹¤í–‰ ë° ì¶”ì²œ ë ˆì‹œí”¼ ìƒì„± ì¤‘..."):
                        # Execute core recipes
                        core_results = pipeline.execute_core_recipes(disease_name)

                        # Get LLM recommendations
                        recommended = pipeline.recommend_additional_recipes(disease_name, target_count=7)

                        # Store in session state
                        st.session_state.pipeline_core_results = core_results
                        st.session_state.pipeline_recommended = recommended
                        st.session_state.pipeline_disease_name = disease_name

                        # Initialize checkbox states (all checked by default)
                        if 'pipeline_checkboxes' not in st.session_state:
                            st.session_state.pipeline_checkboxes = {}
                        for recipe_name in recommended:
                            if recipe_name not in st.session_state.pipeline_checkboxes:
                                st.session_state.pipeline_checkboxes[recipe_name] = True

                    st.success(f"âœ… '{disease_name}' ë¶„ì„ ì¤€ë¹„ ì™„ë£Œ!")
                else:
                    st.warning("âš ï¸ ì§ˆí™˜ëª…ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")

            # Step 3: Show core results and recommendations
            if 'pipeline_core_results' in st.session_state:
                st.divider()
                st.subheader("2ï¸âƒ£ ìë™ ì‹¤í–‰ë  í•µì‹¬ ë¶„ì„ (4ê°œ)")

                core_success = sum(1 for r in st.session_state.pipeline_core_results if r.get('success', False))
                st.info(f"âœ… {core_success}/{len(st.session_state.pipeline_core_results)} ê°œ í•µì‹¬ ë ˆì‹œí”¼ ì¤€ë¹„ë¨")

                with st.expander("í•µì‹¬ ë ˆì‹œí”¼ ìƒì„¸ë³´ê¸°"):
                    for result in st.session_state.pipeline_core_results:
                        if result.get('success'):
                            st.markdown(f"**âœ“ {result['recipe_name']}**")
                            st.caption(result.get('metadata', {}).get('description', 'N/A'))
                        else:
                            st.markdown(f"**âœ— {result['recipe_name']}** - âŒ Error: {result.get('error', 'Unknown')}")

                st.divider()
                st.subheader("3ï¸âƒ£ ì¶”ì²œ ë¶„ì„ ì„ íƒ")
                st.markdown(f"**'{st.session_state.pipeline_disease_name}'** ì§ˆí™˜ì— ì í•©í•œ {len(st.session_state.pipeline_recommended)}ê°œ ì¶”ê°€ ë¶„ì„ì´ ì¶”ì²œë˜ì—ˆìŠµë‹ˆë‹¤.")

                # Display checkboxes for recommended recipes
                st.markdown("**ì²´í¬ë°•ìŠ¤ë¡œ ì›í•˜ëŠ” ë¶„ì„ì„ ì„ íƒí•˜ì„¸ìš”:**")

                # Initialize checkboxes if not exists
                if 'pipeline_checkboxes' not in st.session_state:
                    st.session_state.pipeline_checkboxes = {}

                for idx, recipe_name in enumerate(st.session_state.pipeline_recommended):
                    recipe = pipeline.recipe_loader.get_recipe_by_name(recipe_name)
                    description = recipe.get('description', 'No description') if recipe else 'Recipe not found'

                    # Initialize checkbox state if not exists
                    if recipe_name not in st.session_state.pipeline_checkboxes:
                        st.session_state.pipeline_checkboxes[recipe_name] = True

                    # Checkbox for each recipe with unique key using index
                    is_checked = st.checkbox(
                        f"**{recipe_name}**",
                        value=st.session_state.pipeline_checkboxes[recipe_name],
                        key=f"pipeline_cb_{idx}_{recipe_name[:20]}",
                        help=description
                    )
                    st.session_state.pipeline_checkboxes[recipe_name] = is_checked
                    st.caption(f"ğŸ“ {description}")
                    st.markdown("")

                # Natural language refinement
                st.divider()
                st.subheader("4ï¸âƒ£ ìì—°ì–´ë¡œ ì¶”ê°€ ìš”ì²­ (ì„ íƒì‚¬í•­)")
                nl_feedback = st.text_area(
                    "ì¶”ê°€ë¡œ ì›í•˜ëŠ” ë¶„ì„ì´ ìˆìœ¼ë©´ ìì—°ì–´ë¡œ ì…ë ¥í•˜ì„¸ìš”",
                    placeholder="ì˜ˆ: ë¹„ìš© ê´€ë ¨ ë¶„ì„ì„ ë” ì¶”ê°€í•´ì¤˜\nì˜ˆ: ì‹œê°„ ê²½ê³¼ì— ë”°ë¥¸ ë¶„ì„ì€ ë¹¼ì¤˜",
                    help="ì²´í¬ë°•ìŠ¤ ì„ íƒì„ ìì—°ì–´ë¡œ ì¡°ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤",
                    key="pipeline_nl_feedback"
                )

                if nl_feedback and st.button("ğŸ”„ ì¶”ì²œ ì¡°ì •", key="refine_recommendations"):
                    with st.spinner("ğŸ¤– ìì—°ì–´ í”¼ë“œë°± ë°˜ì˜ ì¤‘..."):
                        refined = pipeline.refine_recommendations_with_nl(
                            st.session_state.pipeline_disease_name,
                            st.session_state.pipeline_recommended,
                            nl_feedback
                        )
                        st.session_state.pipeline_recommended = refined

                        # Reset checkboxes for new recommendations
                        st.session_state.pipeline_checkboxes = {}
                        for recipe_name in refined:
                            st.session_state.pipeline_checkboxes[recipe_name] = True

                        st.rerun()

                # Final execution button
                st.divider()
                st.subheader("5ï¸âƒ£ ìµœì¢… ì‹¤í–‰")

                approved_count = sum(1 for checked in st.session_state.pipeline_checkboxes.values() if checked)
                total_count = 4 + approved_count  # 4 core + approved additional

                st.info(f"ì´ **{total_count}ê°œ** ë ˆì‹œí”¼ê°€ ì‹¤í–‰ë©ë‹ˆë‹¤ (í•µì‹¬ 4ê°œ + ì„ íƒ {approved_count}ê°œ)")

                if st.button(f"ğŸš€ {total_count}ê°œ ë ˆì‹œí”¼ ì‹¤í–‰", type="primary", key="execute_pipeline"):
                    # Get approved recipes
                    approved_recipes = [
                        name for name, checked in st.session_state.pipeline_checkboxes.items()
                        if checked
                    ]

                    with st.spinner(f"â³ {total_count}ê°œ ë ˆì‹œí”¼ ì‹¤í–‰ ì¤‘..."):
                        # Execute all approved recipes
                        approved_results = pipeline.execute_approved_recipes(
                            st.session_state.pipeline_disease_name,
                            approved_recipes
                        )

                        # Combine with core results
                        all_results = st.session_state.pipeline_core_results + approved_results

                        # Calculate success rate
                        success_count = sum(1 for r in all_results if r.get('success', False))
                        success_rate = success_count / len(all_results) if all_results else 0

                        # Store results
                        st.session_state.pipeline_final_results = all_results
                        st.session_state.pipeline_success_rate = success_rate

                    st.success(f"âœ… ë¶„ì„ ì™„ë£Œ! ì„±ê³µë¥ : {success_rate*100:.1f}% ({success_count}/{len(all_results)})")
                    st.balloons()

            # Step 4: Display final results
            if 'pipeline_final_results' in st.session_state:
                st.divider()
                st.header("ğŸ“Š ë¶„ì„ ê²°ê³¼")

                results = st.session_state.pipeline_final_results
                success_rate = st.session_state.pipeline_success_rate

                # Summary metrics
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("ì´ ì‹¤í–‰ ë ˆì‹œí”¼", len(results))
                with col2:
                    success_count = sum(1 for r in results if r.get('success', False))
                    st.metric("ì„±ê³µ", success_count)
                with col3:
                    st.metric("ì„±ê³µë¥ ", f"{success_rate*100:.1f}%")

                # Display each result
                st.subheader("ìƒì„¸ ê²°ê³¼")
                for idx, result in enumerate(results, 1):
                    recipe_name = result.get('recipe_name', 'Unknown')
                    success = result.get('success', False)

                    if success:
                        with st.expander(f"âœ… {idx}. {recipe_name}", expanded=False):
                            metadata = result.get('metadata', {})
                            st.markdown(f"**ì„¤ëª…:** {metadata.get('description', 'N/A')}")

                            params = result.get('parameters', {})
                            if params:
                                st.markdown("**íŒŒë¼ë¯¸í„°:**")
                                st.json(params)

                            st.markdown("**ìƒì„±ëœ SQL:**")
                            st.code(result.get('sql_query', 'No SQL'), language='sql')
                    else:
                        with st.expander(f"âŒ {idx}. {recipe_name} - ì‹¤íŒ¨", expanded=False):
                            st.error(f"ì˜¤ë¥˜: {result.get('error', 'Unknown error')}")

    except ImportError:
        st.error("âŒ Disease Pipeline ëª¨ë“ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. `disease_pipeline.py` íŒŒì¼ì„ í™•ì¸í•˜ì„¸ìš”.")
    except Exception as e:
        st.error(f"âŒ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")

# Tab 3: AI ì¿¼ë¦¬ ìƒì„± (NL2SQL - Pattern II RAG)
# IMPROVED VERSION with better UX for SQL code generation workflow
with main_tabs[2]:
    st.header("ğŸ¤– AI ê¸°ë°˜ ì¿¼ë¦¬ ìƒì„±")

    # P0.1: Purpose clarity banner
    st.info("""
ğŸ“Œ **ì´ ë„êµ¬ëŠ” SQL ì½”ë“œ ìƒì„±ê¸°ì…ë‹ˆë‹¤**
â€¢ âœ… ìì—°ì–´ â†’ SQL ì¿¼ë¦¬ ìë™ ë³€í™˜
â€¢ âœ… ìƒì„±ëœ SQLì„ ë³µì‚¬í•˜ì—¬ Databricksì—ì„œ ì‹¤í–‰
â€¢ âŒ ì´ í™”ë©´ì—ì„œëŠ” ë°ì´í„°ë¥¼ ì¡°íšŒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤
    """)

    st.markdown("""
    ìì—°ì–´ë¡œ ìš”ì²­í•˜ë©´ ìŠ¤í‚¤ë§ˆì™€ ì°¸ì¡° ë°ì´í„°ë¥¼ í™œìš©í•˜ì—¬ SQLì„ ìë™ ìƒì„±í•©ë‹ˆë‹¤.
    **ë ˆì‹œí”¼ ì—†ì´** ììœ ë¡œìš´ ë°ì´í„° íƒìƒ‰ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
    """)

    # Initialize NL2SQL generator
    try:
        from nl2sql_generator import NL2SQLGenerator

        if 'nl2sql_generator' not in st.session_state:
            with st.spinner("NL2SQL Generator ì´ˆê¸°í™” ì¤‘..."):
                st.session_state.nl2sql_generator = NL2SQLGenerator()

        # User input
        st.subheader("ğŸ“ ìì—°ì–´ ìš”ì²­")

        # P2.1: Prompt engineering help
        with st.expander("ğŸ’¡ íš¨ê³¼ì ì¸ ìš”ì²­ ì‘ì„±ë²•", expanded=False):
            st.markdown("""
            ### ì¢‹ì€ ìš”ì²­ ì˜ˆì‹œ:

            âœ… **êµ¬ì²´ì ì¸ ì§ˆë¬¸**
            - "ê³ í˜ˆì•• í™˜ìì˜ ì„±ë³„ ë¶„í¬ë¥¼ ë³´ì—¬ì£¼ì„¸ìš”"
            - "ë‹¹ë‡¨ë³‘ í™˜ìì—ê²Œ ê°€ì¥ ë§ì´ ì²˜ë°©ëœ ì•½ë¬¼ TOP 10"

            âœ… **ì¡°ê±´ í¬í•¨**
            - "ì„œìš¸ ì§€ì—­ 3ì°¨ ë³‘ì›ì—ì„œ ì¹˜ë£Œë°›ì€ ì•” í™˜ìëŠ” ëª‡ ëª…?"
            - "ìµœê·¼ 1ë…„ê°„ ê³ í˜ˆì••ìœ¼ë¡œ ì²˜ë°©ë°›ì€ ì•½ë¬¼ ì„±ë¶„ë³„ í™˜ì ìˆ˜"

            âŒ **í”¼í•´ì•¼ í•  ìš”ì²­**
            - "ê³ í˜ˆì••" (ë„ˆë¬´ ëª¨í˜¸í•¨)
            - "Show me hypertension patients" (ì˜ë¬¸ ì§€ì› ì•ˆ ë¨)
            - "ëª¨ë“  ì •ë³´ ë³´ì—¬ì¤˜" (ë²”ìœ„ ë¶ˆëª…í™•)

            ### ìš”ì²­ êµ¬ì¡° íŒ¨í„´:
            `[ì§ˆí™˜ëª…] + [ë¶„ì„ ëŒ€ìƒ] + [ì¡°ê±´(ì„ íƒ)]`
            - ì§ˆí™˜ëª…: "ê³ í˜ˆì••", "ë‹¹ë‡¨ë³‘", "ì•”"
            - ë¶„ì„ ëŒ€ìƒ: "í™˜ì ìˆ˜", "ì„±ë³„ ë¶„í¬", "ì²˜ë°© ì•½ë¬¼"
            - ì¡°ê±´: "ì§€ì—­", "ë³‘ì› ë“±ê¸‰", "ê¸°ê°„"
            """)

        # Example queries
        example_queries = [
            "ê³ í˜ˆì•• í™˜ìì˜ ì„±ë³„ ë¶„í¬ë¥¼ ë³´ì—¬ì£¼ì„¸ìš”",
            "ë‹¹ë‡¨ë³‘ í™˜ìì—ê²Œ ê°€ì¥ ë§ì´ ì²˜ë°©ëœ ì•½ë¬¼ TOP 10",
            "ì„œìš¸ ì§€ì—­ 3ì°¨ ë³‘ì›ì—ì„œ ì¹˜ë£Œë°›ì€ ì•” í™˜ìëŠ” ëª‡ ëª…ì¸ê°€ìš”?",
            "ìµœê·¼ 1ë…„ê°„ ê³ í˜ˆì••ìœ¼ë¡œ ì²˜ë°©ë°›ì€ ì•½ë¬¼ ì„±ë¶„ë³„ í™˜ì ìˆ˜",
        ]

        selected_example = st.selectbox(
            "ì˜ˆì‹œ ì¿¼ë¦¬ ì„ íƒ (ì„ íƒì‚¬í•­)",
            ["ì§ì ‘ ì…ë ¥"] + example_queries,
            key="nl2sql_example"
        )

        if selected_example != "ì§ì ‘ ì…ë ¥":
            default_query = selected_example
        else:
            default_query = ""

        user_query = st.text_area(
            "ë¬´ì—‡ì„ ë¶„ì„í•˜ê³  ì‹¶ìœ¼ì‹ ê°€ìš”?",
            value=default_query,
            height=100,
            placeholder="ì˜ˆ: ê³ í˜ˆì•• í™˜ì ì¤‘ ì„œìš¸ ì§€ì—­ 3ì°¨ ë³‘ì›ì—ì„œ ì¹˜ë£Œë°›ì€ í™˜ìì˜ ì—°ë ¹ëŒ€ë³„ ë¶„í¬",
            help="êµ¬ì²´ì ìœ¼ë¡œ ì‘ì„±í• ìˆ˜ë¡ ì •í™•í•œ SQLì´ ìƒì„±ë©ë‹ˆë‹¤",
            key="nl2sql_query_input"
        )

        col1, col2 = st.columns([1, 5])
        with col1:
            generate_button = st.button("ğŸš€ SQL ìƒì„±", type="primary", key="nl2sql_generate")

        if generate_button and user_query:
            with st.spinner("SQL ìƒì„± ì¤‘..."):
                result = st.session_state.nl2sql_generator.generate_sql(user_query)

            if result.success:
                st.success("âœ… SQL ìƒì„± ì™„ë£Œ!")

                # P1.2: SQL first (most important output)
                st.subheader("ğŸ“ ìƒì„±ëœ SQL")

                # P1.1: SQL quality indicators
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("í…Œì´ë¸” ì‚¬ìš©", len(result.analysis.get('required_tables', [])))
                with col2:
                    st.metric("ì¡°ê±´ ìˆ˜", len(result.analysis.get('key_conditions', [])))
                with col3:
                    complexity = "ê°„ë‹¨" if len(result.sql_query.split('\n')) < 10 else "ë³´í†µ" if len(result.sql_query.split('\n')) < 20 else "ë³µì¡"
                    st.metric("ë³µì¡ë„", complexity)

                # Display SQL with line numbers
                st.code(result.sql_query, language="sql", line_numbers=True)

                # P0.2: Improved copy mechanism
                col1, col2 = st.columns([3, 7])
                with col1:
                    st.download_button(
                        label="ğŸ’¾ SQL íŒŒì¼ ë‹¤ìš´ë¡œë“œ",
                        data=result.sql_query,
                        file_name="generated_query.sql",
                        mime="text/plain",
                        key="nl2sql_download",
                        help="SQLì„ .sql íŒŒì¼ë¡œ ì €ì¥ í›„ Databricksì—ì„œ ì‹¤í–‰í•˜ì„¸ìš”"
                    )

                st.caption("ğŸ’¡ **Tip**: SQL ì½”ë“œ ë¸”ë¡ì„ ë§ˆìš°ìŠ¤ë¡œ ì„ íƒí•˜ì—¬ ë³µì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤ (Ctrl+C / Cmd+C)")

                # P1.3: SQL Validation
                def validate_databricks_sql(sql: str) -> dict:
                    """Validate SQL against Databricks/Spark SQL rules"""
                    issues = []
                    warnings = []

                    # Critical issues
                    if "deleted = FALSE" not in sql and "basic_treatment" in sql:
                        issues.append("basic_treatment í…Œì´ë¸” ì‚¬ìš© ì‹œ 'deleted = FALSE' í•„í„° í•„ìˆ˜")

                    if "deleted = FALSE" not in sql and "prescribed_drug" in sql:
                        issues.append("prescribed_drug í…Œì´ë¸” ì‚¬ìš© ì‹œ 'deleted = FALSE' í•„í„° í•„ìˆ˜")

                    # Date conversion issues
                    if "res_treat_start_date" in sql:
                        if "CAST" in sql and "AS DATE" in sql:
                            issues.append("res_treat_start_dateëŠ” YYYYMMDD ë¬¸ìì—´ - TO_DATE(res_treat_start_date, 'yyyyMMdd') ì‚¬ìš© í•„ìˆ˜")
                        elif "TO_DATE(res_treat_start_date)" in sql and "yyyyMMdd" not in sql:
                            issues.append("TO_DATEëŠ” í˜•ì‹ ì§€ì • í•„ìˆ˜ - TO_DATE(res_treat_start_date, 'yyyyMMdd')")

                    # Warnings
                    if "res_treat_start_date" in sql and "TO_DATE" not in sql:
                        warnings.append("res_treat_start_date ë‚ ì§œ ë¹„êµ ì‹œ TO_DATE(res_treat_start_date, 'yyyyMMdd') ë³€í™˜ í•„ìš”")

                    if "REGEXP" in sql:
                        warnings.append("Spark SQLì—ì„œëŠ” RLIKE ì‚¬ìš© ê¶Œì¥ (REGEXP ëŒ€ì‹ )")

                    return {"issues": issues, "warnings": warnings}

                validation = validate_databricks_sql(result.sql_query)

                if validation['issues']:
                    st.error("ğŸš¨ **SQL ê²€ì¦ ì‹¤íŒ¨** - ì‹¤í–‰ ì „ ìˆ˜ì • í•„ìš”:")
                    for issue in validation['issues']:
                        st.markdown(f"- âŒ {issue}")

                if validation['warnings']:
                    st.warning("âš ï¸ **ê¶Œì¥ì‚¬í•­**:")
                    for warning in validation['warnings']:
                        st.markdown(f"- {warning}")

                if not validation['issues'] and not validation['warnings']:
                    st.success("âœ… Databricks í˜¸í™˜ì„± ê²€ì¦ í†µê³¼")

                # P1.2: Analysis in expander (less prominent)
                with st.expander("ğŸ“Š ë¶„ì„ ìƒì„¸ì •ë³´", expanded=False):
                    analysis_col1, analysis_col2 = st.columns(2)

                    with analysis_col1:
                        st.markdown("**ì˜ë„ ë¶„ì„**")
                        st.info(result.analysis.get('intent', 'N/A'))

                        st.markdown("**ì£¼ìš” ì¡°ê±´**")
                        if result.analysis.get('key_conditions'):
                            for condition in result.analysis['key_conditions']:
                                st.markdown(f"- {condition}")

                    with analysis_col2:
                        st.markdown("**ì‚¬ìš©ëœ í…Œì´ë¸”**")
                        tables = result.analysis.get('required_tables', [])
                        for table in tables:
                            st.code(table, language="text")

                        if result.relevant_examples:
                            st.markdown("**ì°¸ê³ í•œ ì˜ˆì‹œ**")
                            for ex in result.relevant_examples:
                                st.markdown(f"- {ex}")

                # Explanation
                if result.analysis.get('explanation'):
                    with st.expander("ğŸ’¬ ì¿¼ë¦¬ ì„¤ëª…"):
                        st.markdown(result.analysis['explanation'])

                # P2.3: Learning section
                with st.expander("ğŸ“š ë¹„ìŠ·í•œ ì§ˆë¬¸ íŒ¨í„´ ë°°ìš°ê¸°", expanded=False):
                    st.markdown(f"""
                    ### ì´ ì¿¼ë¦¬ì™€ ë¹„ìŠ·í•œ íŒ¨í„´:

                    **í˜„ì¬ ìš”ì²­**: {user_query}

                    **ë™ì¼ íŒ¨í„´ ë‹¤ë¥¸ ì§ˆí™˜**:
                    - "{user_query.replace('ê³ í˜ˆì••', 'ë‹¹ë‡¨ë³‘')}"
                    - "{user_query.replace('ê³ í˜ˆì••', 'ì•”')}"

                    **ì¡°ê±´ ì¶”ê°€ ë²„ì „**:
                    - "{user_query} (ìµœê·¼ 1ë…„)"
                    - "{user_query} (ì„œìš¸ ì§€ì—­ ë³‘ì›)"

                    **ë‹¤ë¥¸ ë¶„ì„ ê°ë„**:
                    """)

                    if "ì„±ë³„" in user_query:
                        st.markdown("- ê°™ì€ ì§ˆí™˜ì˜ 'ì—°ë ¹ëŒ€ë³„ ë¶„í¬'")
                        st.markdown("- ê°™ì€ ì§ˆí™˜ì˜ 'ì§€ì—­ë³„ ë¶„í¬'")
                    elif "ì•½ë¬¼" in user_query or "ì²˜ë°©" in user_query:
                        st.markdown("- ê°™ì€ ì§ˆí™˜ì˜ 'ì²˜ë°© ì„±ë¶„ë³„ í™˜ì ìˆ˜'")
                        st.markdown("- ê°™ì€ ì§ˆí™˜ì˜ 'ì²˜ë°© ë¹ˆë„ ì¶”ì´'")

            else:
                # P0.3: Error with recovery guidance
                st.error(f"âŒ SQL ìƒì„± ì‹¤íŒ¨: {result.error_message}")

                with st.expander("ğŸ”§ ë¬¸ì œ í•´ê²° ê°€ì´ë“œ", expanded=True):
                    st.markdown("""
                    ### SQL ìƒì„± ì‹¤íŒ¨ ì‹œ í™•ì¸ì‚¬í•­:

                    1. **ì§ˆí™˜ëª… í™•ì¸**
                       - âœ… ì •í™•í•œ í•œê¸€ ì§ˆí™˜ëª… ì‚¬ìš© (ì˜ˆ: "ê³ í˜ˆì••", "ë‹¹ë‡¨ë³‘")
                       - âŒ ì˜ë¬¸ëª…ì€ ì¸ì‹ ì•ˆ ë¨ (ì˜ˆ: "hypertension" â†’ "ê³ í˜ˆì••")

                    2. **ìš”ì²­ êµ¬ì²´í™”**
                       - âœ… "ê³ í˜ˆì•• í™˜ìì˜ ì„±ë³„ ë¶„í¬"
                       - âŒ "ê³ í˜ˆì•• ì •ë³´" (ë„ˆë¬´ ëª¨í˜¸í•¨)

                    3. **í…Œì´ë¸” ì œì•½ í™•ì¸**
                       - ì‚¬ìš© ê°€ëŠ¥: basic_treatment, prescribed_drug, insured_person, hospital
                       - ì§ˆí™˜ í•„í„°: basic_treatment.res_disease_name
                       - ì•½ë¬¼ ì •ë³´: prescribed_drug.res_drug_name

                    4. **ì˜ˆì‹œ ì¿¼ë¦¬ ì°¸ê³ **
                       - ìœ„ì˜ ì˜ˆì‹œ ì„ íƒ ë“œë¡­ë‹¤ìš´ì—ì„œ ìœ ì‚¬í•œ íŒ¨í„´ í™•ì¸
                    """)

                    st.info("ğŸ’¡ **ì¶”ì²œ**: ìœ„ì˜ 'ì˜ˆì‹œ ì¿¼ë¦¬ ì„ íƒ'ì—ì„œ ìœ ì‚¬í•œ ì§ˆë¬¸ì„ ì„ íƒí•´ë³´ì„¸ìš”")

        elif generate_button:
            st.warning("âš ï¸ ìì—°ì–´ ìš”ì²­ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")

    except ImportError:
        st.error("NL2SQL Generatorë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. nl2sql_generator.py íŒŒì¼ì„ í™•ì¸í•˜ì„¸ìš”.")
    except Exception as e:
        st.error(f"ì˜¤ë¥˜ ë°œìƒ: {str(e)}")

# Tab 4: ë¦¬í¬íŠ¸ ë³´ê¸° (Report viewer - placeholder for saved analyses)
with main_tabs[3]:
    st.header("ğŸ“Š ì €ì¥ëœ ë¦¬í¬íŠ¸ ë³´ê¸°")
    st.info("ì €ì¥ëœ ë¶„ì„ ê²°ê³¼ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ê¸°ëŠ¥ì€ í–¥í›„ ì—…ë°ì´íŠ¸ ì˜ˆì •ì…ë‹ˆë‹¤.")

    # Placeholder for future functionality
    st.markdown("""
    **í–¥í›„ ì œê³µ ì˜ˆì • ê¸°ëŠ¥:**
    - ì´ì „ ë¶„ì„ ê²°ê³¼ ëª©ë¡ ë³´ê¸°
    - ë¶„ì„ ê²°ê³¼ ì €ì¥ ë° ë¶ˆëŸ¬ì˜¤ê¸°
    - ë¶„ì„ ê²°ê³¼ ë¹„êµ
    - PDF/Excel ë‚´ë³´ë‚´ê¸°
    """)

# Tab 4: Clinical Trial Screening (deprecated - will be removed)
# Commented out for Phase 6, kept for reference
if False and CLINICAL_TRIAL_AVAILABLE and len(main_tabs) > 3:
    with main_tabs[3]:
        st.header("ğŸ¥ Clinical Trial Screening Automation")
        st.markdown("ìì—°ì–´ ì„ìƒì‹œí—˜ ì¡°ê±´ì„ ì…ë ¥í•˜ë©´ ìë™ìœ¼ë¡œ ì í•©í•œ SQL ì¿¼ë¦¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.")

        # Sub-tabs for different functionalities
        trial_sub_tabs = st.tabs(["ğŸš€ ìŠ¤í¬ë¦¬ë‹ ì‹¤í–‰", "ğŸ” ê¸°ì¤€ ë¶„ì„"])

        # Tab 1: Screening Execution (existing functionality)
        with trial_sub_tabs[0]:
            st.subheader("ì„ìƒì‹œí—˜ ì¡°ê±´ ì…ë ¥")
            col1, col2 = st.columns(2)
            with col1:
                trial_name = st.text_input(
                    "ì„ìƒì‹œí—˜ëª…",
                    value="ê³ í˜ˆì•• ì‹ ì•½ ì„ìƒì‹œí—˜",
                    help="ë¶„ì„í•  ì„ìƒì‹œí—˜ì˜ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”",
                    key="screening_trial_name"
                )
                inclusion_criteria = st.text_area(
                    "í¬í•¨ ê¸°ì¤€ (Inclusion Criteria)",
                    value="""ë§Œ 19ì„¸ ì´ìƒ ì„±ì¸ ë‚¨ë…€
Visit 1 ê¸°ì¤€ í‰ê·  ì¢Œìœ„ ìˆ˜ì¶•ê¸° í˜ˆì••ì´ 140-180 mmHg ë²”ìœ„
í•­ê³ í˜ˆì••ì œ ë³µìš© ì¤‘ì¸ ê²½ìš°, ì‹œí—˜ìì˜ íŒë‹¨ì— ë”°ë¼ ì¹˜ë£Œ ì¤‘ë‹¨ì´ ê°€ëŠ¥í•œ í™˜ì
ì—¬ì„± ëŒ€ìƒìì˜ ê²½ìš° í”¼ì„ ì¡°ê±´ ì¶©ì¡±
ì‹œí—˜ ëª©ì Â·ë‚´ìš© ì„¤ëª…ì„ ë“£ê³  ìë°œì  ì„œë©´ ë™ì˜ë¥¼ í•œ í™˜ì""",
                    height=150,
                    help="í™˜ìê°€ ì„ìƒì‹œí—˜ì— ì°¸ì—¬í•˜ê¸° ìœ„í•œ í¬í•¨ ì¡°ê±´ë“¤ì„ ì…ë ¥í•˜ì„¸ìš”",
                    key="screening_inclusion_criteria"
                )
            with col2:
                exclusion_criteria = st.text_area(
                    "ì œì™¸ ê¸°ì¤€ (Exclusion Criteria)",
                    value="""Visit 1 ë˜ëŠ” Visit 2ì—ì„œ MSSBP â‰¥ 180 mmHg ë˜ëŠ” MSDBP â‰¥ 110 mmHg
ìµœê·¼ 5ë…„ ì´ë‚´ ì•…ì„±ì¢…ì–‘ ë³‘ë ¥
ìµœê·¼ 12ê°œì›” ì´ë‚´ ì‹¬ê·¼ê²½ìƒ‰ ë˜ëŠ” ë‡Œì¡¸ì¤‘ ë³‘ë ¥
ì„ì‹ ë¶€ ë˜ëŠ” ìˆ˜ìœ ë¶€
ì•½ë¬¼ ë˜ëŠ” ì•Œì½”ì˜¬ ë‚¨ìš© ë³‘ë ¥
ì‹œí—˜ì•½ ì„±ë¶„ì— ê³¼ë¯¼ì¦ ê¸°ì™•ë ¥""",
                    height=150,
                    help="ì„ìƒì‹œí—˜ì—ì„œ ì œì™¸ë˜ì–´ì•¼ í•  ì¡°ê±´ë“¤ì„ ì…ë ¥í•˜ì„¸ìš”",
                    key="screening_exclusion_criteria"
                )

                # Execution options
                dry_run = st.checkbox(
                    "Dry Run ëª¨ë“œ (SQL ìƒì„±ë§Œ, ì‹¤í–‰ ì•ˆí•¨)",
                    value=True,
                    help="ì²´í¬í•˜ë©´ SQL ì¿¼ë¦¬ë§Œ ìƒì„±í•˜ê³  ì‹¤ì œ ì‹¤í–‰ì€ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤",
                    key="screening_dry_run"
                )
                comprehensive_analysis = st.checkbox(
                    "ì¢…í•© ë¶„ì„ ëª¨ë“œ (ê¸°ë³¸ ìŠ¤í¬ë¦¬ë‹ + LLM ê¸°ë°˜ ì¶”ê°€ ë¶„ì„)",
                    value=False,
                    help="ì²´í¬í•˜ë©´ ê¸°ë³¸ ìŠ¤í¬ë¦¬ë‹ í›„ LLMì„ í™œìš©í•œ ì¶”ê°€ ë¶„ì„ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤",
                    key="screening_comprehensive"
                )

            # Initialize clinical trial agent
            if 'clinical_agent' not in st.session_state:
                with st.spinner("ì„ìƒì‹œí—˜ ì—ì´ì „íŠ¸ ì´ˆê¸°í™” ì¤‘..."):
                    try:
                        st.session_state.clinical_agent = ClinicalTrialAgent()
                        st.success("âœ… ì„ìƒì‹œí—˜ ì—ì´ì „íŠ¸ ì¤€ë¹„ ì™„ë£Œ!")
                    except Exception as e:
                        st.error(f"ì„ìƒì‹œí—˜ ì—ì´ì „íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
                        st.stop()

            # Execute screening button
            st.divider()
            if st.button("ğŸš€ ìŠ¤í¬ë¦¬ë‹ ì‹¤í–‰", type="primary", key="execute_screening_button"):
                if not trial_name or not inclusion_criteria or not exclusion_criteria:
                    st.warning("âš ï¸ ì„ìƒì‹œí—˜ëª…, í¬í•¨ ê¸°ì¤€, ì œì™¸ ê¸°ì¤€ì„ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.")
                else:
                    with st.spinner("ğŸ”„ ì„ìƒì‹œí—˜ ìŠ¤í¬ë¦¬ë‹ ì§„í–‰ ì¤‘..."):
                        try:
                            # Choose analysis mode
                            if comprehensive_analysis:
                                result = st.session_state.clinical_agent.run_comprehensive_clinical_analysis(
                                    trial_name=trial_name,
                                    inclusion_criteria=inclusion_criteria,
                                    exclusion_criteria=exclusion_criteria,
                                    dry_run=dry_run
                                )
                                analysis_type = "ì¢…í•© ë¶„ì„"
                            else:
                                result = st.session_state.clinical_agent.run_clinical_trial_screening(
                                    trial_name=trial_name,
                                    inclusion_criteria=inclusion_criteria,
                                    exclusion_criteria=exclusion_criteria,
                                    dry_run=dry_run
                                )
                                analysis_type = "ê¸°ë³¸ ìŠ¤í¬ë¦¬ë‹"

                            # Store results in session state
                            st.session_state.screening_result = result
                            st.session_state.screening_analysis_type = analysis_type

                            st.success(f"âœ… {analysis_type} ì™„ë£Œ!")

                        except Exception as e:
                            st.error(f"âŒ ìŠ¤í¬ë¦¬ë‹ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
                            st.exception(e)

            # Display results if available
            if 'screening_result' in st.session_state:
                st.divider()
                st.subheader(f"ğŸ“Š {st.session_state.screening_analysis_type} ê²°ê³¼")

                result = st.session_state.screening_result

                # Display metrics
                if 'all_executed_recipes' in result:  # Comprehensive analysis
                    recipes = result['all_executed_recipes']
                    success_rate = result.get('overall_success_rate', 0)
                else:  # Basic screening
                    recipes = result.get('execution_results', [])
                    success_rate = result.get('success_rate', 0)

                col1, col2 = st.columns(2)
                with col1:
                    st.metric("ì‹¤í–‰ëœ ë ˆì‹œí”¼", f"{len(recipes)}ê°œ")
                with col2:
                    st.metric("ì„±ê³µë¥ ", f"{success_rate:.1%}")

                # Display LLM insights if available (comprehensive analysis)
                if 'llm_insights' in result:
                    st.subheader("ğŸ¤– LLM ì¸ì‚¬ì´íŠ¸")
                    insights = result['llm_insights']

                    with st.expander("ì„ìƒì  ì˜ë¯¸ (Clinical Significance)", expanded=True):
                        st.markdown(insights.get('clinical_significance', 'N/A'))

                    with st.expander("ê¶Œì¥ ì¶”ê°€ ë¶„ì„ (Recommended Analyses)"):
                        st.markdown(insights.get('recommended_analyses', 'N/A'))

                    with st.expander("ë°ì´í„° ë¶€ì¡± ì˜ì—­ (Data Gaps)"):
                        st.markdown(insights.get('data_gaps', 'N/A'))

                    with st.expander("ë‹¤ìŒ ë‹¨ê³„ ì œì•ˆ (Next Steps)"):
                        st.markdown(insights.get('next_steps', 'N/A'))

                # Display individual recipe results
                st.subheader("ğŸ“ ìƒì„±ëœ SQL ì¿¼ë¦¬")
                for idx, recipe_result in enumerate(recipes):
                    # Handle both dict and QueryResult object
                    if isinstance(recipe_result, dict):
                        recipe_name = recipe_result.get('recipe_name', 'Unknown')
                        success = recipe_result.get('success', False)
                        sql_query = recipe_result.get('sql_query', 'No SQL generated')
                        parameters = recipe_result.get('parameters')
                        error_msg = recipe_result.get('error', 'Unknown error')
                    else:  # QueryResult object
                        recipe_name = getattr(recipe_result, 'recipe_name', 'Unknown')
                        success = getattr(recipe_result, 'success', False)
                        sql_query = getattr(recipe_result, 'generated_sql', 'No SQL generated')
                        parameters = getattr(recipe_result, 'parameters', None)
                        error_msg = getattr(recipe_result, 'error_message', 'Unknown error')

                    status_icon = "âœ…" if success else "âŒ"
                    with st.expander(f"{status_icon} {idx+1}. {recipe_name}", expanded=False):
                        if success:
                            st.code(sql_query, language="sql")

                            # Display parameters used
                            if parameters:
                                st.json(parameters)
                        else:
                            st.error(f"ì‹¤íŒ¨ ì‚¬ìœ : {error_msg}")

        # Tab 2: Criteria Analysis (new functionality with file/text input)
        with trial_sub_tabs[1]:
            st.subheader("ğŸ” ê¸°ì¤€ ì¿¼ë¦¬ ê²€ì¦ ê°€ëŠ¥ì„± ë¶„ì„")
            st.info("âœ… UI ì¤‘ë³µ ë¬¸ì œ í•´ê²°ë¨! ê° íƒ­ì´ ë…ë¦½ì ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤.")
            st.markdown("ì„ìƒì‹œí—˜ ê¸°ì¤€ ì „ì²´ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì—¬ ë¶„ì„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")

            # Input method selection
            input_method = st.radio(
                "ì…ë ¥ ë°©ë²• ì„ íƒ:",
                ["ğŸ“ ì§ì ‘ í…ìŠ¤íŠ¸ ì…ë ¥", "ğŸ“ íŒŒì¼ ì—…ë¡œë“œ"],
                key="criteria_input_method"
            )

            # Input section
            trial_name_analysis = None
            full_criteria_text = None

            if input_method == "ğŸ“ ì§ì ‘ í…ìŠ¤íŠ¸ ì…ë ¥":
                trial_name_analysis = st.text_input(
                    "ì„ìƒì‹œí—˜ëª…",
                    value="",
                    help="ë¶„ì„í•  ì„ìƒì‹œí—˜ì˜ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”",
                    key="analysis_trial_name"
                )

                full_criteria_text = st.text_area(
                    "ì„ìƒì‹œí—˜ ê¸°ì¤€ ì „ì²´ í…ìŠ¤íŠ¸",
                    value="""ì„ìƒì‹œí—˜ëª…: ê³ í˜ˆì•• ì‹ ì•½ íš¨ëŠ¥ í‰ê°€ ì—°êµ¬

ì„ ì •ê¸°ì¤€:
1. ë§Œ 19ì„¸ ì´ìƒ 75ì„¸ ì´í•˜ì˜ ì„±ì¸ ë‚¨ë…€
2. ê³ í˜ˆì•• ì§„ë‹¨ì„ ë°›ê³  í˜„ì¬ í•­ê³ í˜ˆì••ì œë¥¼ ë³µìš© ì¤‘ì¸ í™˜ì
3. ìµœê·¼ 6ê°œì›” ì´ë‚´ í˜ˆì••ì´ 140/90 mmHg ì´ìƒìœ¼ë¡œ ì¸¡ì •ëœ í™˜ì
4. ì—°êµ¬ ì°¸ì—¬ì— ì„œë©´ ë™ì˜í•œ í™˜ì

ì œì™¸ê¸°ì¤€:
1. ì„ì‹  ë˜ëŠ” ìˆ˜ìœ  ì¤‘ì¸ ì—¬ì„±
2. ì‹¬ê°í•œ ê°„ê¸°ëŠ¥ ë˜ëŠ” ì‹ ê¸°ëŠ¥ ì¥ì• ê°€ ìˆëŠ” í™˜ì
3. ìµœê·¼ 3ê°œì›” ì´ë‚´ ì‹¬ê·¼ê²½ìƒ‰ì´ë‚˜ ë‡Œì¡¸ì¤‘ ë³‘ë ¥ì´ ìˆëŠ” í™˜ì""",
                    height=300,
                    help="ì„ìƒì‹œí—˜ ê¸°ì¤€ ì „ì²´ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.",
                    key="analysis_full_text"
                )

            elif input_method == "ğŸ“ íŒŒì¼ ì—…ë¡œë“œ":
                uploaded_file = st.file_uploader(
                    "ì„ìƒì‹œí—˜ ê¸°ì¤€ íŒŒì¼ ì—…ë¡œë“œ",
                    type=["txt"],
                    help="ì„ìƒì‹œí—˜ ê¸°ì¤€ì´ í¬í•¨ëœ í…ìŠ¤íŠ¸ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì„¸ìš”",
                    key="criteria_file_upload"
                )

                if uploaded_file is not None:
                    try:
                        full_criteria_text = str(uploaded_file.read(), "utf-8")
                        trial_name_analysis = uploaded_file.name.replace('.txt', '')

                        st.text_area(
                            "ì—…ë¡œë“œëœ íŒŒì¼ ë‚´ìš© ë¯¸ë¦¬ë³´ê¸°:",
                            value=full_criteria_text[:1000] + "..." if len(full_criteria_text) > 1000 else full_criteria_text,
                            height=200,
                            disabled=True,
                            key="file_preview"
                        )
                    except Exception as e:
                        st.error(f"íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: {e}")

            # Analysis section
            if trial_name_analysis and full_criteria_text:
                if st.button("ğŸ“Š ê¸°ì¤€ ë¶„ì„ ì‹¤í–‰", help="ì „ì²´ í…ìŠ¤íŠ¸ì—ì„œ ê¸°ì¤€ì„ ì¶”ì¶œí•˜ê³  ê²€ì¦ ê°€ëŠ¥ì„±ì„ ë¶„ì„í•©ë‹ˆë‹¤", key="criteria_analysis_button"):
                    if QUERYABLE_CRITERIA_AVAILABLE:
                        with st.spinner("ì„ìƒì‹œí—˜ ê¸°ì¤€ ìë™ ì¶”ì¶œ ë° ë¶„ì„ ì¤‘..."):
                            try:
                                # Initialize analyzer
                                if 'criteria_analyzer' not in st.session_state:
                                    st.session_state.criteria_analyzer = QueryableCriteriaAnalyzer()

                                # Parse the full text to extract inclusion/exclusion criteria
                                inclusion_text, exclusion_text = parse_criteria_text(full_criteria_text)

                                # Analyze criteria
                                analysis_result = st.session_state.criteria_analyzer.analyze_trial_criteria(
                                    trial_name=trial_name_analysis,
                                    inclusion_criteria=inclusion_text,
                                    exclusion_criteria=exclusion_text
                                )

                                # Store result in session state
                                st.session_state.criteria_analysis_result = analysis_result

                                st.success("âœ… ê¸°ì¤€ ë¶„ì„ ì™„ë£Œ!")

                                # Display results
                                total_criteria = analysis_result['total_criteria_count']
                                queryability_ratio = analysis_result['overall_queryability_ratio']

                                col1, col2, col3 = st.columns(3)
                                with col1:
                                    st.metric("ì´ ê¸°ì¤€ ìˆ˜", f"{total_criteria}ê°œ")
                                with col2:
                                    st.metric("ì¿¼ë¦¬ ê²€ì¦ ê°€ëŠ¥ë¥ ", f"{queryability_ratio:.1%}")
                                with col3:
                                    queryable_count = int(total_criteria * queryability_ratio)
                                    st.metric("ê²€ì¦ ê°€ëŠ¥í•œ ê¸°ì¤€", f"{queryable_count}ê°œ")

                            except Exception as e:
                                st.error(f"âŒ ê¸°ì¤€ ë¶„ì„ ì‹¤íŒ¨: {e}")
                                st.exception(e)
                    else:
                        st.warning("QueryableCriteriaAnalyzerë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. GEMINI_API_KEYë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.")
            else:
                st.info("ì„ìƒì‹œí—˜ëª…ê³¼ ê¸°ì¤€ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ê³  ë¶„ì„ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.")

else:
    if not CLINICAL_TRIAL_AVAILABLE:
        st.info("ì„ìƒì‹œí—˜ ìŠ¤í¬ë¦¬ë‹ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ë ¤ë©´ clinical_trial_agent.py íŒŒì¼ì´ í•„ìš”í•©ë‹ˆë‹¤.")
